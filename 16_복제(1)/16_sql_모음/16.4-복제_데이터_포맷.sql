## 16.4 - 복제 데이터 포맷
/**
  변경 이벤트들이 바이너리 로그에 어떤 형태로 저장되는지 나타내는 바이너리 로그 로깅 포맷 타입에 대해 살펴보자.
  바이너리 로그에 이벤트가 어떤 포맷으로 기록되는지는 복제가 처리되는 과정에도 영향을 주는데,
  레플리카 서버가 소스 서버의 바이너리 로그 이벤트를 내부적으로 가공하지 않고 가져온 그대로 실행해 자신의 데이터에 적용하므로
  복제에서 어떤 바이너리 로그 포맷을 사용하느냐는 중요한 부분이다.

  바이너리 로그 로깅 포맷 타입으로 Statement와 Row 방식이 있다. 두 방식은 어떤 것일까? (469p)
  Statement : 실행된 SQL문을 바이너리 로그에 기록하는 방식이다. (가장 오래된 방식이다. 5.7이전 기본)
  Row : 변경된 데이터 자체를 기록하는 방식이다.
  binlog_format 시스템 변수를 통해 이 두가지 종류중 하나로 설정하거나 혼합된 형태로 사용할 수 있다.
 */

### 16.4.1 - Statement 기반 바이너리 로그 포맷
/**
  Statement 포맷 형식은 실행된 SQL문이 그대로 바이너리 로그에 저장돼 있는 것을 확인할 수 있다.
  하나의 SQL문은 여러 개의 데이터를 수정할 수 있는데, 이 경우 Statement 포맷에서는 바이너리 로그에 SQL문 하나만 기록된다.
  이렇게 되면 로그 파일의 용량이 작아져서 사용자 입장에서 저장 공간에 대한 부담을 덜 수 있고,
  원격으로 바이너리 로그를 백업하거나 레플리카 서버와 복제할 때도 좀 더 빠르게 처리될 수 있다.
  바이너리 로그는 변경 내역이 전부 저장되는 파일이므로 감사 등의 목적으로도 활용될 수 있는데,
  Statement 포맷을 사용하면 손쉽게 SQL문들을 확인할 수 있으므로 감사에 더 용이하다.

  단점.
    - 비확정적(Non-Deterministic)으로 처리될 수 있는 쿼리가 실행된 경우 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달리질 수 있다.
    - Row 포맷으로 복제될 때보다 데이터에 더 많은 락을 건다.

  Statement 포맷 기반 복제에서 소스 서버와 레플리카 서버 간의 데이터 일관성을 해칠 수 있는 비확정적 쿼리 유형 예시
    - DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT 사용
    - SELECT ... FRO UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAIT이나 SKIP LOCKED 옵션 사용
    - LOAD_FILE(), UUID(), UUID_SHORT(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같은 함수를 사용하는 쿼리
    - 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리

  Row 포맷으로 복제될 때보다 더 많은 락을 거는 이유
    - Row 포맷인 경우 레플리카 서버에는 변경된 데이터 자체가 넘어가서 적용되므로 소스 서버에서처럼 쿼리를 실행해 처리하는 형태가 아니다.
     이 때문에 동일한 데이터 변경일지라도 락을 더 적게 점유하고 처리 속도도 훨씬 빠르다.

  Statement 기반 바이너리 로그 포맷을 사용할 경우 제한 사항으로 트랜잭션 격리 레벨을 반드시 `REPEATABLE READ` 이상이어야 한다.
  그 이하의 방식에서는 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 데이터 스냅샷이 달라져서 안 된다.
 */

### 16.4.2 - Row 기반 바이너리 로그 포맷
/**
  Row 기반 바이너리 로그 포맷은 5.1 버전부터 도입된 포맷으로 데이터 변경이 발생했을 때 변경된 값 자체가 바이너리 로그에 기록되는 방식이다.
  Row 포맷은 어떤 형태의 쿼리가 실행됐든 간에 복제 시 소스 소버와 레플리카 서버의 데이터를 일관되게 하는 가장 안전한 방식이다.
  5.7.7 버전부터 바이너리 로그의 기본 포맷으로 지정됐다.

  Row 포맷에서는 소스 서버에서 실행된 쿼리가 UUID(), USER() 등과 같은 비확정적 함수를 사용해도 레플리카 서버에서 이 함수가 다시 실행되는 것이 아니라
  함수의 결괏값을 전달받아 처리되므로 이 같은 경우에 있어서도 안전하게 복제가 가능하다.
  위에서 얘기했듯이 Statement 보다 락을 더 적게 사용한다.

  단점으로는 다음과 같다.
  실행된 쿼리가 많은 데이터를 변경한 경우 변경된 데이터가 전부 기록되므로 바이너리 로그 파일 크기가 단시간에 매우 커질 수 있다.
  또한, 변경된 데이터 수가 적더라도 BLOB 형태의 큰 값이 새로 저장되거나 변경되는 경우 마찬가지로 파일 크기가 많이 커질 수 있다.
  ROW 포맷은 모든 트랜잭션 격치 수준에서 사용 가능하며,
  Row 포맷으로 설정돼 있어도 사용자 계정 생성과 권한 부여 및 회수, 테이블과 뷰, 트리거 생성 등과 같은 DDL 문은 전부 Statement 포맷 형태로 기록된다.
 */

### 16.4.3 - Mixed 포맷
/**
  Statement, Row 포맷을 혼합해서 사용하고 싶으면 binlog_format 시스템 변수를 MIXED 값으로 지정하면 된다.
  Mixed 포맷은 기본적으로 Statement 포맷을 사용하며, 실행된 쿼리와 스토리지 엔진의 종류에 따라 필요 시 자동으로 Row 포맷으로 전환해서 로그에 기록한다.
  만약, 실행된 쿼리가 Statement 포맷으로 기록되어 복제 됐을 때 문제가 된다면 Row 포맷으로 변환되어 기록한다.
  여기서 복제 됐을 때 문제가 되는 쿼리는 비확정적으로 처리될 수 있는 쿼리 유형을 뜻한다.

  MySQL 서버가 자동으로 두 포맷을 번갈아 사용하는 것이므로 예상했던 것과 다르게 처리될 수 있다.
  따라서, MIXED 포맷만이 제일 좋은 방법이 아니다. 사용하는 쿼리 형태에 제일 적합한 방식을 고려해서 설정하자.
 */

### 16.4.4 - Row 포맷의 용량 최적화
/**
  Row 기반의 바이너리 포맷을 사용할지 망설이는 이유는 Statement 포맷을 사용할 때보다 로그 파일의 용량이 더 커질 수 있다는 점이다.
  Row 포맷을 사용할 때 바이너리 로그 파일 용량을 줄일 수 있는 두 가지 방법을 살펴보자.
 */

#### 16.4.4.1 - 바이너리 로그 Row 이미지
/**
  Row 포맷의 바이너리 로그 파일 용량 최소화를 위해 저장되는 변경 데이터의 컬럼 구성을 제어하는 binlog_row_image라는 시스템 변수를 활용하자.
  Row 포맷을 사용할 경우 바이너리 로그에는 각 변경 데이터마다 변경 전 레코드와 변경 후 레코드가 함께 저장되는데,
  binlog_row_image 시스템 변수는 각 변경 전후 레코드들에 대해 테이블의 어떤 컬럼들을 기록할 것인지를 결정한다.

  binlog_row_image 시스템 변수는 다음과 같이 세 개의 옵션 중에서 하나를 설정할 수 있으며 기본값은 full로 설정된다.
    - full
        특정 컬럼에서만 변경 여부와 관계없이 "변경이 발생한 레코드의 모든 컬럼들의 값을 바이너리 로그에 기록"하는 방식
    - minimal
        변경 데이터에 대해 "꼭 필요한 컬럼들의 값만 바이너리 로그에 기록"한다.
    - noblob
        full 옵션을 설정한 것과 동일하게 작동하지만 레코드의 "BLOB이나 TEXT 컬럼에 대해 변경이 발생하지 않은 경우 해당 컬럼들은 기록하지 않는다".

  binlog_row_image 변수는 Statement 포맷을 사용하는 경우 아무런 영향이 없으며, MIXED 방식인 경우 Row 포맷으로 저장되는 변경 데이터에 한해서만 적용된다
 */

#### 16.4.4.2 - 바이너리 로그 트랜잭션 압축
/**
  일반적으로 바이너리 로그는 안정적인 복제를 위해 일정 기간 동안 보관되도록 설정하며, 시점 복구(Point-In-Time Recovery)를 고려하는 경우에는
  원격 스토리지 서버에 바이너리 로그들을 백업해두기도 한다. 따라서 생성되는 바이너리 로그 파일의 양이 많은 경우에는 디스크 공간, 네트워트 대역폭을 많이 소비한다.

  8,0.20 버전에서 Row 포맷으로 기록되는 트랜잭션에 대해 변경한 데이터를 압축해서 바이너리 로그에 기록할 수 잇께 하는 기능이 도입됐다.
  트랜잭션 압축 기능이 활성화 돼 있으면 변경한 데이터들을 zstd 알고리즘을 사용해 압축한 뒤,
  Transaction_payload_event 라는 하나의 이벤트로 바이너리 로그에 기록한다.
  압축된 트랜잭션 데이터는 레플리카 서버로 복제될 때도 압축된 사앹를 유지하며, 레플리카 서버의 I/O 스레드도 압축된 상태 그대로 릴레이 로그에 기록한다.
  따라서 소스 서버, 레플리카 서버 모두 디스크 공간이 절약되고 네트워크 대역폭 사용량도 줄어든다.
  그러나 주의해야 할 점은 소스 서버에서 바이너리 로그 압축이 적용된 경우 레플리카 서버도 반드시 바이너리 로그 압축을 지원하는 8.0.20 버전 이상이여야 한다.

  binlog_transaction_compression 시스템 변수를 이용해 압축 기능을 활성화 할 수 있으며, 압축 시 사용될 zstd 알고리즘 레벨을 설정할 수 있다.
  binlog_transaction_compression_level_zstd 변수를 이용해 설정할 수 있다. 1 ~ 22까지 정하면 되고, 기본값은 3이다.
  압축 레벨이 높을수록 압축률이 증가해 디스크 공간이나 네트워크 대역폭을 더 절약할 수 있다는 장점이 있지만 CPU와 메모리 사용량이 늘어나고 처리 시간이 증가한다.
  또한 압축 레벨이 높다고 해서 반드시 압축률이 좋아지는 것은 아니다.

  위 두 시스템 변수는 세션별로도 설정할 수 잇어서 글로벌하게 압축 기능을 적용하지 않고 세션에서 트랜잭션별로 선택적으로 압축 기능을 적용할 수 있다.
  이 말은 바이너리 로그에 압축된 트랜잭션 데이터와 압축되지 않은 트랜잭션 데이터가 같이 존재할 수 있다는 것인데, 문제가 되지 않는다.
  왜냐면 바이너리 로그 트랜잭션 압축은 모든 경우에 대해 압축을 적용하지 않는다. 대표적인 몇 가지만 알아보자.
    - GTID 설정 관련 이벤트
    - 그룹 복제에서 발생하는 View Change 이벤트, Heartbeat 이벤트와 같은 제어 이벤트
    - 복제 실패 및 소스 서버와 레플리카 서버 간 데이터 불일치를 발생시킬 수 잇는 Incident 타입의 이벤트
    - 트랜잭션을 지원하지 않는 스토리지 엔진에 대한 이벤트 및 그러한 이벤트를 포함하고 있는 트랜잭션 이벤트
    - Statement 포맷으로 기록되는 트랜잭션 이벤트(MIXED 포맷으로 설정돼 있는 경우 해당, 트랜잭션 압축 기능은 Row 포맷으로 기록되는 이벤트들에만 적용)
 */
select @@binlog_transaction_compression;
select @@binlog_transaction_compression_level_zstd;

-- performance 스키마에서 binary_log_transaction_compression_state 테이블에 바이너리 로그와 릴레이 로그에 기록된 압축 통계 정보가 저장된다.
SELECT * FROM performance_schema.binary_log_transaction_compression_stats;

-- 압축 성능과 관련해서 트랜잭션의 압축 및 압축 해제에 소요된 시간을 확인하기 위해 performance 스키마 update 하기
UPDATE performance_schema.setup_instruments
SET ENABLED='YES', TIMED='YES'
WHERE NAME IN ('stage/sql/Compressing transaction changes.',
               'stage/sql/DEcompressing transaction changes.');

-- 압축 기능을 사용하면 오버헤드로 인해 쿼리 처리가 지연될 수 있고 서버의 자원도 더 소모하게 되므로 압축 기능을 사용하고자 할 때는 잘 판단해서 사용하자.
