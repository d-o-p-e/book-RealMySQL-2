# 16. MySQL 복제

## 16.1 개요

가용성과 확장성을 위해 MySQL 복제를 사용할 수 있다.

1. 스케일아웃
2. 데이터 백업
3. 데이터 분석
4. 데이터의 지리적 분산


## 16.2 복제 아키텍처
Q. 릴레이 로그가 무엇인가요?
> 소스 서버의 바이너리 로그를 읽어서 레플리카의 로컬에 저장한 파일

## 16.3 복제 타입

### 16.3.1 파이너리 로그 파일 기반 복제

Q. 바이너리 로그 파일 기반 복제에서 이벤트를 식별하는 방법?
> 바이너리 로그 파일의 이름과 파일 내에서의 오프셋을 사용한다.

### 16.3.1.2 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기
Q. 어떤 경우에 트랜잭션을 건너뛰어야 할까요?
> 레플리카 서버에서 소스 서버로부터 넘어 온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제가 멈추는 경우에, 해당 문제의 트랜잭션을 건너뛰어도 괜찮은 경우

Q. 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰는 방법?
> 복제를 중단한 후 sal_slave_ skip._counter 변수의 값을 1로 지정해 레플리케이션 sOL. 스 레드를 재시작하면 레플리카 서버는 에러가 발생한 INSERT 쿼리를 건너뛰고 정상적으로 복제를 재개

### 16.3.2 글로벌 트랜잭션 아이디 GTID 기반 복제
Q. 파이너리 로그 파일 기반 복제의 문제점은?
> 파일 명으로 식별하기 때문에, 복제 DB마다 같은 식별값을 보장하지 않는다 -> 레플리카를 활용한 장애복구(failover) 가 힘들다

Q. 파일 기반 복제에서 장애가 났을 때 레플리카들 끼리의 동기화가 힘든 이유
> 1. 동일한 파일 구조로 되어 있는지 알 수 없다.
> 2. 릴레이 로그로 복구를 시도한다고 해도, 릴레이 로그는 일정 시간이 지나면 삭제되기 때문에 제한적
> 그래서 아키텍처가 복잡할수록 자동화가 힘들다

### 16.3.2.4 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기
Q. GTID 에서는 트랜잭션을 어떻게 건너뛸까요?
> 트랜잭션을 레플리카 서버에서 무시하려면 복제를 멈추고 빈 트랜잭 션을 강제로 만들어서 바이너리 로그 스트림에 밀어넣으면 된다.


이건 사실 좀 모르겠습니다.

Q. 책에서 다음 내용들이 GTID에서 문제가 발생한다고 나와있는데, 이유는?
• 트랜잭션을 지원하는 테이블과 지원하지 않는 테이블을 함께 변경하는 쿼리 혹은 트랜잭션
• CREATE TABLE ...SELECT ...구문
• 트랜잭션 내에서 CREATE TEWPORARY TABLE, DROP TEMPORARY TABLE 구문 사용

> 만약 소스 서버 에서 단일 트랜잭션으로 처리된 쿼리들이 바이너리 로그에 기록되고 레플리카 서버로 복제되는 과정에 서 하나의 트랜잭션이 아닌 개별적인 이벤트로 분류되고 각각에 대해 GTID가 할당되면, 레플리카 서 버에서 해당 트랜잭션이 원자적으로 처리되지 못할 수 있다


## 16.4 복제 데이터 포맷

### 16.4.1 Statement 기반 바이너리 로그 포맷
Q. Statement 기반 바이너리 로그 포맷의 장점?
> Statement 포맷에서는 바이너리 로그에 SOL문 하나만 기록된다.
> - 바이너리 로그 파일의 용량이 작아짐
> - 원격 서버 간의 백업이나 복제에서 더 빠르게 처리될 수 있다. -> 네트워크 전송 시간 때문에 말하는듯 

Q. 단점? (두가지 )

> 1. 비확정적(Non-Deterministic)으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달라질 수 있다
> • DELETE/UPDATE 7÷2|0||11 ORDER BY 810| LIMIT ^18
> • SELECT ...FOR UPDATE 및 SELECT ...FOR SHARE 쿼리에서 NOWAITOIL SKIP LOCKED 옵션 사용
> • LOAD_FILE(). UUID(), UUID_ SHORT(), USER(). FOUND_ROWS(), RAND(). VERSION() 등과 같은 함수를 사용하는 쿼리
> • 동일한 파라미터 값을 입력하더라도 결맛값이 달라질 수 있는 사용자 정의 함수(user-defined Function)나 스토어드 프로시저(Stored Procedure)를 사용하는 쿼리

> 2. 락을 많이 건다. row 포맷이 사용된 경우 레플리카 서버에는 변경된 데이터 자체가 넘어가서 적용되므로 소스 서버에서처럼 쿼리를 실행해 처리하는 형태가 아니기 때문에 동일한 데이터 변경일지라도 락을 더 적게 점유하고 처리 속도 도 훨씬 빠르다고 할 수 있다.


Q. 제한사항? 격리수준
> Repeatable Read -> ??? ㅋㅋㅋㅋ

### 16.4.2 Row 기반 바이너리 로그 포맷

Q. 변경된 데이터가 그대로 바이니리 로그에 기록된다는 것의 장점과 단점?
> - 장점: 락 최소화, 비확정적 쿼리에 있어서도 안전한 복제
> - 단점: MySQL 서버에서 실행된 쿼리가 굉장히 많은 데이터를 변경한 경우에는 변경된 데이터가 전부 기록되 므로 바이너리 로그 파일 크기가 단시간에 매우 커질 수 있다.

격리수준 제한도 없다.

### 16.4.3 Mixed
Q. 무엇인가요?
> - 쿼리의 경우 대부분 Statement 포맷
> - 실행된 쿼리가 Statement 포맷으로 기록되어 복제됐을 때 문제가 될 가능성이 있는 안전하지 못한 쿼리 형태라면 Row 포맷으로 변환

### 16.4.4 RoW 포맷의 용량 최적화
ROw 포맷으로 기록되는 트랜잭션에 대해 트랜잭션에서 변경한 데이터를 압 축해서 바이너리 로그에 기록할 수 있게 하는 기능이 도입됐

압축된 트랜잭션 데이터는 레플리카 서버로 복제될 때도 압축된 상태를 유지하며 레플리카 서버의 레플리케이션 1/O 스레드도 압축된 상태 그대로 릴레이 로그에 기록한다

Q. 압축 기능을 사용하면 어떤 단점을 고려해야하나요?
> - 압축 기능을 사용하면 오버헤드로 인해 압축 기능을 사용하지 않을 때보다 쿼리 처리가 지연될 수 있고 서버의 자원도 더 소모하게 된다.
> - 서버의 리소스 사용률 현황과 서비스 요건을 충족시키는 쿼리 응답 속도 등을 파악한 후 별도로 구축한 테스트 환 경에서 성능을 확인해 압축 기능의 사용 여부를 결정하는 것이 좋다.


## 16.5 복제 동기화 방식

### 16.5.1 비동기 복제(Asynchronous replication)

Q. 무엇인가요?
> 소스 서버가 자신과 복제 연결된 레플리카 서버에서 변경 이벤트가 정상적으로 전달되어 적용됐는지를 확인하지 않는 방식
> - 비동기 = 결과에 관심 없음


### 16.5.2 반동기 복제(Semi-synchronous replication)

Q. 무엇인가요?
> 이벤트를 릴레이 로그에 기 록후 응답(ACK)을 보내면 그때 트랜잭션을 완전히 커밋시키고 클라이언트에 결과를 반환

Q. AFTER_SYNC VS AFTER COMMIT
> - AFTER_SYNC: 레플리카 서버가 릴레이 로그를 디스크에 기록한 후 응답을 보내면 트랜잭션을 커밋
> - AFTER COMMIT: 레플리카 서버가 릴레이 로그를 디스크에 기록한 후 트랜잭션을 커밋하고 응답을 보냄

Q. AFTER COMMIT 사용에서 발생하는 문제점은?
> 레플리카 전달 중에 장애나면, 팬텀리드 발생

반동기 복제는 물리적으로 가깝게 위치한 레플리카 서버와의 복제에 더 적합


Q. 모든 레플리카에서 응답을 받아야 클라이언트에게 응답을 준다 (O / X)
> X. 기준 설정 가능!
