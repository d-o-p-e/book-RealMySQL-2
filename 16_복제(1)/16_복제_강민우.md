---

### 볼 만한 링크

- https://typefully.com/dylayed/PzIV7Qs
    - https://github.com/taeold

### 16.2 - 복제 아키텍처

> MySQL의 복제는 세 개의 스레드에 의해 작동한다.
다음과 세 개의 스레드 중 소스 서버에서 열리는 스레드는 무엇일까? (432p)
1. `바이너리 로그 덤프 스레드`
2. `레플리케이션 I/O 스레드`
3. `레플리케이션 SQL 스레드`
- 1. `바이너리 로그 덤프 스레드`는 소스 서버에서 열리고, 나머지 두 스레드는 레플리카 서버에서 열린다.
    - 소스 서버에서는 레플리카 서버가 연결될 때 내부적으로 바이너리 로그 덤프 스레드를 생성해서 바이너리 로그의 내용을 레플리카 서버로 전송한다.
    - 이 스레드는 소스 서버에서 `SHOW PROCESSLIST` 명령을 통해 확인할 수 있다.


>`바이너리 로그 덤프 스레드(Binary Log Dump Thread)`가 하는 일은 무엇일까? (432p)
> 
- 바이너리 로그 덤프 스레드는 복제본으로 전송될 각 이벤트를 읽을 때 소스의 바이너리 로그에 대한 잠금을 획득한다.  
이벤트를 읽은 즉시 이벤트가 복제본으로 전송되기 전에 잠금이 해제된다.
>`레플리케이션 I/O 스레드(Replication I/O Thread`) 가 하는 일은 무엇일까? (432p)
- 소스 서버의 `바이너리 로그 덤프 스레드`로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일(릴레이 로그)로 저장하는 역할을 담당한다.
- 소스 서버의 바이너리 로그를 읽어서 파일로 쓰는 역할만 하기 때문에 I/O 스레드라고 명명된 것이다.

> `레플리케이션 SQL 스레드(Replication SQL Thread)` 가 하는 일은 무엇일까? (432p)
>
- `레플리케이션 I/O 스레드`에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.


> 다음 두 상황을 예측해보자 (432p)
1. 복제를 진행하던 중 **레플리카 서버**의 장애가 발생했다. 이렇게 될 경우 소스 서버는 어떻게 될까?
2. 복제를 진행하던 중 **소스 서버**의 장애가 발생했다. 이렇게 될 경우 레플리카 서버는 어떻게 될까?
- 두 상황 모두 복제는 진행하지 못 한다.
- 1의 상황은 소스 서버는 아무런 영향이 없다.
- 2의 상황에서 레플리카 서버의 `I/O 스레드`가 정상적으로 동작하지 않게 되므로 복제는 에러를 발생시키고 바로 중단된다. \
  단, 복제 기능만 중단된 것이므로 레플리카 서버가 쿼리를 처리하는 데 아무런 문제가 없다. \
  다만, 소스 서버로부터 동기화되지 못하기 때문에 예전 상태의 데이터를 보게 된다.

> 바이너리 로그 파일 위치 기반으로 복제를 구축할 때 소스 서버에서 바이너리 로그 파일의 모든 이벤트 `server_id` 값이 1이고, \
> 복제할 레플리카 서버의 `server_id`가 기본값으로 설정됐을 때 어떻게 될까? (434p)
>
- `server_id`의 기본값은 1 이다. 동일한 `server_id` 값이 될 경우 자신의 서버에서 발생한 이벤트로 간주해서 레플리카 서버에서 해당 이벤트들을 적용하지 않고 무시한다. \
 즉, 레플리카 서버에서 복제할 모든 이벤트들이 무시된다.

### 15.3.1.1.2 - 복제 계정 준비

> 소스 서버에서 복제을 위한 계정을 만들때 반드시 필요한 권한이 있는데 이 권한은 무엇일까? (437p)
>
- `REPLICATION SLAVE` 권한이 필요하다.

### 16.3.1.2 - 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기

> 레플리카 서버에서 문제가 생긴 소스 서버의 트랜잭션을 무시하고 넘어갈 수 있게 도와주는 시스템 변수가 있는데 이 변수는 어떤 것일까? (442p)
>
- `sql_slave_skip_counter` 시스템 변수를 이용해 문제되는 트랜잭션을 건너뛸 수 있다.

    ```sql
    mysql-Replica> STOP SLAVE SQL_THREAD;
    mysql-Replica> SET GLOBAL sql_slave_skip_counter=1;
    mysql-Replica> START SLAVE SQL_THREAD;
    ```

- 단, 복제를 중단시킨 문제가 심각하다면 수동으로 복구해야 된다. \
  수동으로 복구가 안 된다면 레플리카 서버의 데이터를 모두 버리고 처음부터 다시 레플리카 서버를 구축한 뒤 복제를 구성해야 된다.

> `sql_slave_skip_counter` 시스템 변수를 사용할 때 주의사항으로 무엇이 있을까? (444p)
>
- 스킵되는 범위가 하나의 DML 문장이 아니라 **현재 이벤트를 포함한 이벤트 그룹으로 무시**된다.
- 즉, 하나의 트랜잭션에서 여러 개의 DML 쿼리가 존재하고 있을때 그 중 하나의 DML 문장이 문제가 발생하면 해당 트랜잭션이 모두 무시되어버린다. 이 부분을 주의해야 한다.

### 16.3.2.2 - 글로벌 트랜잭션 아이디

> GTID는 바이너리 로그에 기록된 트랜잭션에만 할당될까? (o / x) (448p)
>
- o : GTID는 커밋되어 **바이너리 로그에 기록된 트랜잭션에 한에서만 할당**된다.
- 데이터 읽기만 수행하는 `SELECT` 쿼리나 `sql_log_bin` 설정이 비활성화돼 있는 상태에서 발생한 트랜잭션은 바이너리에 기록되지 않으므로 GTID가 할당되지 않는다.

> GTID를 기반으로 복제를 구성할 때 제약 사항 공식문서 링크
>
- https://dev.mysql.com/doc/refman/8.0/en/replication-gtids-restrictions.html

> GTID 관련 읽어볼만한 글
>
- https://hoing.io/archives/18445

### 16.3.2.3.1 - 설정 준비 (GTID 쪽)

> `CONNECTION_ADMIN` 권한을 가진 계정은 MySQL 서버가 `read_only`로 설정돼 있다 하더라도 DDL, DML 쿼리가 가능하다.  
> 이를 방지하기 위해 추가할 수 있는 옵션이 있는데 이 옵션은 무엇일까? (454p)
>
- `super_read_only` 옵션을 설정하면 CONNECTION_ADMIN 권한을 가진 사용자가 DDL, DML 쿼리를 실행하더라도 에러를 발생시킨다.
- 복제 서버에서 `super_read_only` 옵션을 적용하면 된다.
- 동적으로 변경 가능하므로 필요한 경우에만 `OFF` 하고, 평소에는 `ON`으로 활성화는 것이 좋다.

### 16.3.2.3.3 - 데이터 복사

> **GTID 기반 복제**에서 레플리카 서버는 `gtid_executed` 값을 기반으로 소스 서버의 복제 이벤트들을 가져온다. 하지만, \
> `gtid_executed` 는 읽기 전용 변수라서 `gtid_purged` 변수 값만 수정할 수 있고, 이 값을 기준으로 `gtid_executed` 값이랑 동일하게 적용된다. \
> 근데, 사용자가 실수로 `gtid_purged`에 잘못된 정보를 입력했을 때 어떻게 수정할 수 있을까? (455p)
>
- `RESET MASTER;` 명령을 통해 두 시스템 변수의 값을 초기화할 수 있다.
- 단, `RESET MASTER;` 명령은 해당 서버가 가지고 있던 바이너리 로그 파일들이 모두 삭제되므로 이 부분을 신경써서 실행해야 한다.
- 근데, `SET GLOBAL gtid_purged=test;` 으로 변경하려고 해도 `Variable 'gtid_purged' can't be set to the value of 'test’;` 에러가 나온다. \
  (이미 등록되어 있어서 그런거 같기도..?) 빈 값에선 테스트해보지 않음.

### 16.3.2.5 - Non-GTID 기반 복제에서 GTID 기반 복제로 온라인 변경

> 바이너리 로그 파일 위치 기반에서 GTID로 변경할 때 필요한 두 시스템 변수는 무엇인가? (463p)
>
- `enforce_gtid_consistency` 와 `gtid_mode` 이 두 변수가 필요하다.
- 위 두 변수 모두 동적으로 변경 가능하다. \
  `SET GLOBAL enforce_gtid_consistency = [OFF | ON | WARN];` \
  `SET GLOBAL gtid_mode = [OFF | OFF_PERMISSIVE | ON_PERMISSIVE | ON];`

> `enforce_gtid_consistency`, `gtid_mode` 두 변수의 역할은 각각 무엇인가. (463p)
>
- `enforce_gtid_consistency`
  - GTID 기반 복제에서 소스 서버와 레플리카 서버 간의 데이터 일관성을 해칠 수 있는 쿼리들이 MySQL 서버에서 실행되는 것을 허용할지 제어하는 변수이다.
- `gtid_mode`
  - 바이너리 로그에 트랜잭션들이 GTID 기반으로 로깅될 수 있는지 여부와 트랜잭션 유형별로 MySQL 서버에서 처리 가능 여부를 제어하는 변수

> `gtid_mode` 에는 `OFF`, `OFF_PERMISSIVE`, `ON_PERMISSIVE`, `ON` 이렇게 네 가지가 있다. \
> 현재 `OFF_PERMISSIVE` 모드를 사용하고 있는 상태에서 `ON` 모드로 변경하려고 하는데 바로 `ON` 모드로 적용할 수 있을까? (o / x) (464p)
>
- x : `gtid_mode` 는 한 번에 한 단계씩만 변경이 가능하다. 따라서, 현재가 `OFF_PERMISSIVE`라면 `ON_PERMISSIVE`로 변경한 뒤 `ON` 모드로 변경할 수 있다.
- 복제 그룹 내에서 소스 서버와 레플리카 서버의 `gtid_mode`를 변경할 때 **서버별로 순차적으로 값 변경**이 이뤄지므로 변경 작업을 진행할 때는 \
  `gtid_mode`가 서로 다른 값으로 설정된 MySQL 서버 사이의 호환성 여부를 확인해보는 것이 좋다.

### 16.4 - 복제 데이터 포맷

> 바이너리 로그 로깅 포맷 타입으로 `Statement`와 `Row` 방식이 있다. 두 방식은 어떤 것일까? (469p)
>
- `Statement` : 실행된 SQL문을 바이너리 로그에 기록하는 방식이다. (가장 오래된 방식이다. 5.7이전 기본)
- `Row` : 변경된 데이터 자체를 기록하는 방식이다.
- `binlog_format` 시스템 변수를 통해 이 두가지 종류중 하나로 설정하거나 혼합된 형태로 사용할 수 있다. (`MIXED` 방식)

### 16.4.1 - Statement 기반 바이너리 로그 포맷

> 복제된 서버에서 `Row` 포맷이 `Statement` 포맷보다 더 적게 락을 사용하게 된다. 왜 그럴까? (470p)
>
- `Row` 포맷이 사용된 복제 서버에선 **변경된 데이터 자체가 넘어가서 적용**되므로 소스 서버에서처럼 쿼리를 실행해 처리하는 형태가 아니기 때문에 \
  동일한 데이터 변경일지라도 락을 더 적게 점유하고 처리 속도도 훨씬 빠르다.

> `Statement` 기반 바이너리 로그 포맷을 사용할 경우 제한 사항으로 트랜잭션 격리 레벨을 어느 수준 이상이여야 되는데 격리 레벨은 어느 수준 이상이여야 할까?(470p)
>
- 반드시 `REPEATABLE READ` 이상이어야 한다.
- 그 이하의 방식에서는 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 데이터 스냅샷이 달라져서 안 된다.

### 16.4.4.2 - 바이너리 로그 트랜잭션 압축

> 소스 서버에서 8.0.20 버전 이상을 사용해 바이너리 로그 압축을 적용했다 이때 새로 레플리카 서버를 구축할 때 주의해야 할 점은 무엇이 있을까? (476 p)
>
- 레플리카 서버의 버전도 바이너리 로그 압축을 지원해야 된다. 즉, 8.0.20 버전 이상을 사용해야 한다.