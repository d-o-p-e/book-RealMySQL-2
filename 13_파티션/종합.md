
# 13 파티션

> 파티션이란? (263p)
>
- 파티션 기능은 테이블을 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리할 수 있게 해준다.

Q. 건환 파티션이 필요한 대표적인 예는?
> 데이터의 특성상 주기적인 삭제가 필요한 경우, 테이블이 너무 커서 인덱스의 크기가 물리적은 메모리의 크기보다 큰 경우

Q. 건환 워킹 셋(Working Set) 이란?
> 테이블 데이터에서 활발하게 사용되는 부분

### 13.1.1 파티션을 사용하는 이유

> 민우 파티션을 언제 사용하면 좋을까? (263p)
>
- 인덱스가 물리적인 메모리보다 훨씬 큰 경우
- 데이터 특성상(ex. 로그) 주기적인 삭제 작업이 필요한 경우

Q. 진우 파티션이 5개라면 인덱스는 몇개인가요?
> 5개

Q. 진우 파티션별로 다른 형태의 인덱스를 사용할 수 있을까요?
> x

Q. 파티션이 없다면 불필요한 데이터 삭제는 어떤식으로 할 수 있을까 ?

> soft delete / hard delete
>
> 파티션 테이블의 레코드 insert
> 파티션 키를 통해 insert되어야할 파티션을 선정 후 일반 테이블에 insert하는 것과 동일하게 처리된다.
>
> 파티션 키 컬럼이 변경될때는 기존 파티션에서 데이터를 삭제 후 신규 파티션에 insert한다.

### 13.1.1.2 데이터의 물리적인 저장소를 분리

Q. 건환 SQL이 수행되기 위해 파티션 테이블을 검색 할 때 성능에 크게 영향을 미치는조건은?
1) WHERE 절의 조건으로 ()을 선택할 수 있는가?
2) WHERE 절의 조건이 ()를 효율적으로 사용할 수 있는가?
> 검색해야할 파티션, 인덱스

> 민우 파티셔닝이란 논리적으로는 하나의 테이블이지만 물리적으로 여러 개의 테이블로 분리해서 관리할 수 있는 기능이다.
> 
> 이때 대용량 테이블 하나를 여러 개의 테이블로 분리했을 때 각각의 테이블 단위로 인덱스를 생성하거나 파티션별로 다른 인덱스를 가질 수 있을까? (o / x) (265p)
>
- x : MySQL 에서는 지원하지 않는다. ([오라클은 가능](https://docs.oracle.com/en/database/oracle/oracle-database/23/vldbg/index-partitioning.html#GUID-40947B49-166F-4377-938F-FED6ECBA6383)하다.)

### 13.1.2.2 - 파티션 테이블의 UPDATE

Q. 진우 Update 쿼리의 where 조건에서 파티션 키가 명시되지 않았다면 어떻게 되나요?
> 전체 파티션을 탐색해야합니다.

> 민우(동일) 파티션으로 나눠진 테이블에 모든 컬럼을 `UPDATE`하는 쿼리를 실행하면서 `WHERE` 조건으로 파티션 키 컬럼이 명시되어 있지 않으면 어떻게 될까? (267p)
>
- 대상 레코드를 차기 위해 테이블의 **모든 파티션을 검색**해야 한다.

Q. 민석 파티션 컬럼에 UPDATE 작업시 DELETE,INSERT 작업이 발생 할 수 있다. (O,X)
> A. O

> 민우 파티션 키 이외의 컬럼만 변경할 때와 파티션 키로 지정된 컬럼이 변경될 때 어떻게 다를까? (267p)
>
- 파티션 키 이외의 컬럼만 변경될 때는 일반 테이블과 마찬가지로 컬럼 값만 변경된다.  
- 파티션 키 컬럼이 변경될 때는 **기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제**한 후 **변경되는 파티션 키 컬럼의 표현식을 평가**하고,  
  그 결과를 이용해 **새로운 파티션을 결정해서 레코드를 새로 저장**한다.

Q. 진우(동일) update 쿼리에서 변경하는 컬럼이 파티션 키라면 어떻게 실행되나요?
> 기존 컬럼 삭제 후 새로 삽입

### 13.1.2.3 - 파티션 테이블의 검색

### 13.1.2.4 - 파티션 테이블의 인덱스 스캔과 정렬

> 민우 파티션 테이블에서 인덱스는 어떤 단위로 생성될까? (269p)
>
- 파티션 단위로 생성된다. (로컬 인덱스에 해당, MySQL 에서 글로벌 인덱스는 지원하지 않는다.)

Q. 민석(동일) 파티션 컬럼에 독립적인 인덱스 생성이 가능하다.
A. X

> 민우 파티션되지 않은 테이블에서 인덱스를 순서대로 읽으면 그 컬럼으로 정렬된 결과를 얻을 수 있다.  
> 그렇다면 파티션 된 테이블에서 인덱스를 순서대로 읽었을 때 정렬된 결과를 가져올까? (o / x) (269p)
>
- x : 파티션 된 테이블에서는 파티션의 순서대로 정렬돼 있지 않다. → 단, ORDER BY 절이 포함된 쿼리의 실행 계획을 보면 Using filesort 부분이 없다.  
 그 이유는 내부적으로 큐 처리를 진행하다 보니 MySQL 서버가 별도의 정렬 작업을 수행하지는 않는다. **머지 & 소트(Merge & Sort) 방법을 사용**한다. (270p)

Q. 진우 여러 파티션에 걸쳐서 인덱스 레인지 스캔으로 정렬된 데이터를 조회하는 경우 어떻게 실행되나요?
> 파티션별로 조회 결과를 우선순위 큐에 넣고, 최종 결과를 큐에서 꺼내서 반환
> ? 그러면 풀테이블 스캔의 경우 그냥 내부 정렬을 하는건가.

Q. 건환 여러 파티션에 대해 인덱스 스캔을 수행하면, 별도의 정렬 작업 없이 정렬된 결과를 바로 반환한다. (O/X)
> X. 별도의 정렬 작업은 없으나, 결과를 바로 반환하는것이 아니라 내부적으로 큐 처리 작업이 수행된다.

Q. 건환 파티션 프루닝이란?
> 최적화 단계에서 필요한 파티션만 골라내고 불 필요한것들은 실행계획에서 배제하는 것

Q. 기현 파티션 프루닝이 되기 위한 조건은?

where절에 파티션 키 조건이 있어야 함.

Q. 진우(동일) 파티션 프루닝은 어떤 경우에 활용 가능한가요? 
> 파티션 키에 의해서 필요한 파티션만 선별할 수 있을때


### 13.2.1 파티션의 제약사항
> 민우 다음 쿼리는 동작할까? (o, x) (272p)
>

```sql
CREATE TABLE tb_article_1 (
    article_id      INT AUTO_INCREMENT NOT NULL,
    reg_date        DATETIME NOT NULL,
    reg_userid      VARCHAR(10),
    PRIMARY KEY (article_id) -- reg_date 를 파티션 키로 설정하고 싶으면 여기에 포함되어야 된다.
) PARTITION BY RANGE ( YEAR(reg_date) ) (
    PARTITION p2009 VALUES LESS THAN (2010),
    PARTITION p2010 VALUES LESS THAN (2011),
    PARTITION p2011 VALUES LESS THAN (2012),
    PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```

- x : `A PRIMARY KEY must include all columns in the table's partitioning function (prefixed columns are not considered).` 에러가 난다.

### 13.2.2.1 파티션과 유니크 키(프라이머리 키 포함)

Q. 기현 파티션키가 모든 UK에 포함되어 있어야 하는 이유는 무엇일까?

로컬 인덱스만을 지원하기 때문에, 해당 row가 모든 파티션에서 유니크함을 보장해야 하기 때문에


Q. 민석 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 컬럼을 포함해야 한다. (O,X)
A. O

- PK 와 같은 유니크 키가 있다면, 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 칼럼을 포함해야 한다.

> 민우 파티션 키를 생성할 때 주의해야 될 사항은 어떤 것일까? (273p)
>
- 파티션 키는 **모든 유니크 인덱스의 일부 또는 모든 컬럼을 포함**해야 한다.

### 13.2.2.2 파티션과 open_files_limit 시스템 변수 설정

Q. 진우 파티션 1000개가 있는 테이블에서 2개의 파티션으로만 푸르닝 된다고 했을 때, 실제 시스템에서 오픈하는 파일의 개수는?
> 1000개. 파티션 개수만큼 열림. open_files_limit 옵션으로 제한 가능
>
> 근데 제한했다가 모자라면 터지는건가

Q. 건환 파티션 테이블이 많을 때 Open_file_limit을 적절하게 설정해줘야 하는 이유는?
> MySQL 에서는 일반적으로 테이블을 파일단위로 관리하는데, 파티션 테이블의 경우 파티션 프루닝이 수행되더라도 일단 동시에 모든 데이터파일을 오픈해야 하기 때문에 성능 관리를 위해 적절하게 설정해줘야 한다.

## 13.3 MySQL 파티션의 종류
Q. 건환 파티션의 종류 4가지와 용도를 간단히 설명하시오.
> 레인지 파티션: 가장 일반적인 방법으로, 파티션키의 연속된 범위로 파티션을 정의하는 방법 

> 리스트 파티션 : 파티션 키 값을 하나하나 리스트로 나열해줘야 하는 파티션 정의 방법 , 리스트, 해시, 키 파티션

> 해시 파티션 : MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법

> 키 파티션 : 해시 파티션과 유사하나, 해시 파티션은 해시 값 계산 방법을 사용자가 명시하는 반면에, 키 파티션은 해시 값의 계산도 MySQL 서버가 수행하게 하는 방법이다. (파티션 키 값을 설정해줌)

### 13.3.1.1 레인지 파티션의 용도

> 민우 레인지 파티션에선 다른 파티션과 달리 명시되지 않은 범위의 키 값이 담긴 레코드를 저장할 수 있는데 어떤 키워드를 이용해 사용할 수 있을까? (276p)
>
- `MAXVALUE` 라는 키워드를 이용해 사용할 수 있다.

> 민우 파티션의 두 가지 장점이 무엇이 있을까? (276p)
>
- 큰 테이블을 작은 크기의 파티션으로 분리
- 필요한 파티션만 접근(쓰기와 읽기 모두) - 이 부분이 효과가 매우 큰 편이다.

### 13.3.1.3.2 - 파티션 삭제

### 13.3.3.2 해시 파티션 테이블 생성

> 민우 해시 파티션을 만들때 파티션 키로 어떤 타입을 사용할 수 있을까? (284p)
>
- 반드시 **정수 타입**만 가능하다.

### 13.3.3.3 해시 파티션의 분리와 병합

> 해시, 키 파티션에서 **특정 파티션**을 두 개 이상의 파티션으로 **분할**또는 **삭제**하려면 어떻게 해야 될까? (286p)
>
- 해시, 키 파티션을 사용하는 테이블에선 특정 파티션을 **분할**과 **삭제** 모두 하지 못한다.

## 13.3.4 키 파티션

> 해시 파티션과 키 파티션의 차이점은? (287p)
>
- 해시 파티션에선 정수 타입이나 정숫값을 반환하는 표현식만 파티션 키로 적용할 수 있는데, 키 파티션은 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있다.  
 또한, 파티션 키의 값을 `MD5()` 함수를 통해 해시 값을 계산하고 그 값을 MOD 연산을 통해 데이터를 각 파티션에 분배하기도 한다.
- `MD5()` 함수를 이용하기 때문에 반드시 정수 타입이 아니어도 사용 가능하다. (289p)

### 13.3.4.1 키파티션의 생성

> 키 파티션 테이블에서 PK 또는 UK 가 있는 상태에서 파티션 키 값을 지정하지 않으면 어떻께 될까? (288p)
>
- PK 또는 UK 모든 컬럼이 파티션 키로 적용된다.

> 키 파티션 테이블을 생성할 때 PK 나 유니크 키가 모두 없는 테이블일 때 파티션 키를 지정하지 않은 경우엔 어떻게 될까? (책에 없음)
>
- 에러가 발생한다.

```sql
CREATE TABLE k1 (
	id INT NOT NULL,
	name VARCHAR(20)
) PARTITION BY KEY ()
	PARTITIONS 2;
-- Field in list of fields for partition function not found in table 에러
```

## 13.3.5 리니어 해시/키 파티션

> 리니어 해시/키 파티션은 기존의 해시/키 파티션과 무엇이 다를까? (289p)
- 기존의 해시/키 티션은 테이블을 삭제/추가 할 때 파티션 전체를 재분배한다.  
 이 단점을 해결하기 위해 `Power-of-two` 알고리즘을 사용해서 파티션의 추가나 통합시 다른 파티션에 미치는 영향을 최소화한다.

## 13.3.6 파티션 테이블의 쿼리 성능

> 파티션을 적용할 때 주의해야할 점은 무엇이 있을까? (292p)
- 파티션 프루닝이 얼마나 잘 일어나는지 확인한 다음 파티션을 적용해야 된다. 파티션 프루닝이 일어나지 않고 전체 파티션을 균등하게 사용하면 오버헤드만 심해질 수 있다.
