13.1.1 파티션을 사용하는 경우
테이블이 인덱스가 물리적 메모리를 초과 할 경우
데이터 특성상 주기적인 삭제 작업이 필요한 경우
파티션과 비슷한 샤딩 정리 글 공유
https://velog.io/@minstone/%EC%83%A4%EB%94%A9


13.1.1.1 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리
인덱스가 커질수록 SELECT 및 INSERT,UPDATE,DELETE 작업도 함께 느려지는 단점이 존재함. 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용, 효과적으로 처리한다.

13.1.1.3 이력 데이터의 효율적인 관리
불필요한 데이터 삭제 작업은 파티션을 추가하거나 삭제하는 방식으로 빠르게 해결 할 수 있다.

13.1.2 파티션 테이블의 레코드 INSERT,UPDATE
ISERT 작업 시 파티션 키값과 파티션 표현식을 평가해 레코드가 저장될 적절한 파티션을 결정한다.
UPDATE 작업에서 파티션 키가 업데이트 되면, 기존 레코드를 삭제하고 적절한 파티션 위치에 레코드를 저장한다.
UPDATE 작업에서 WHERE절에 파티션키 가 없다면, 변경대상을 찾기위해 모든 파티션을 탐색 할 수 있다.
Q. 파티션 컬럼에 UPDATE 작업시 DELETE,INSERT 작업이 발생 할 수 있다. (O,X)
A. O


13.1.2.3 파티션 테이블의 검색
검색 성능에 영향을 미치는 조건

WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
WHERE 절의 조건이 인덱스를 효율적으로 사용(인덱스 레인지 스캔) 할 수 있는가?

13.1.2.3 파티션 테이블의 인덱스 스캔과 정렬
파티션과 관계없이 테이블 전체 단위로 사용 할 수 있는 인덱스를 지원하지 않는다.
파티션 개별로 특별한(?) 인덱스를 생성 할 수 없다.
파티션단위로 저장되기에, 인덱스가 있더라도 파티션별로SORT-MERGE 과정을 수행 할 수 있다.
Q. 파티션 컬럼에 독립적인 인덱스 생성이 가능하다.
A. X


13.2.1 파티션의 제약 사항
MySQL 내장 함수로 파티션 생성 가능 할 수 있지만, 파티션 프루닝을 지원하지 않을 수 있다.
프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 컬럼을 포함해야 한다.
8192개의 파티션을 가질 수 있다.
공간 데이터를 저장하는 컬럼타입은 파티션 테이블에서 사용 할 수 없다.
파티션 컬럼이 많아지면, DUMP 및 복원에서 큰 속도 저하를 보여줍니다.


13.2.2.1 파티션과 유니크 키
프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 컬럼을 포함해야 한다.
Q. 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 컬럼을 포함해야 한다. (O,X)
A. O


13.2.2.2 파티션과 open_files_limit 시스템 변수 설정
open_files_limit 시스템 변수에 동시에 오픈할 수 있는 적절한 파일의 개수를 설정 할 수 있다.
파티션 테이블은 파티션개수 * 2~3 개의 테이블파일을 열 수 있기에 해당 변수를 적절하게 조정해야 한다.

13.3.1 레인지 파티션
다음의 용도에서 사용한다.

날짜를 기반으로 데이터가 누적되 연도나 월, 일단위로 분석하고 삭제해야 할 때
범위 기간으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
파티션 키 위주로 검색이 자주 실행될 때
레인지 파티션 장점

큰 테이블을 작은 크기의 파티션으로 분리
필요한 파티션만 접근(쓰기와 읽기 모두)
파티션의 추가 및 삭제

ALTER TABLE ... ADD PARTITION 명령으로 추가 할 수 있으나,
LESS THAN MAXVALUE 파티션을 사용할경우 REORGANIZE PARTITION 명령을 사용해야 한다.
DROP PARTITION 명령으로 삭제 가능하며, 가장 오래된 파티션만 삭제 할 수 있다.(추가도 가장 최신의 파티션만 추가 가능함)
기존 파티션의 분리 / 병합

REORGANIZE PARTITION 명령을 사용해 가능하다.
분리작업은 레코드를 세로 복사해야 하기때문에 기존 레코드 건수에 따라 작업시간이 결정된다.
ALGORITHM과 LOCK을 사용해 ONLINE DDL을 유도하면 좋다.
읽기 잠금이 걸리기에 쓰기가 불가하다는것에 주의하자.

13.3.3.3 해시 파티션
-해시 파티션은 특정 파티션의 키 값을 MOD로 연산하여 레코드가 저장될 파티션을 결정한다.

mod 연산이란? - 어떤 한 숫자를 다른 숫자로 나눈 나머지를 구하는 연산

해시 파티션 삭제/분할

해시나 키 파티션은 파티션 단위로 레코드를 삭제하는 방법이 없다.
분할하는 기능또한 없으며, 테이블 전체적으로 파티션을 늘리는 것만 가능하다.
해시 파티션 병합

COALESCE PARITITION 명령을 사용하면 되며, 재구성하는 작업이 수행된다.
재구성을 하게되면, 리빌드작업이 따라오므로 다른 트랜잭션의 데이터 변경이 허용되지 않는다.

13.3.3.3 키 파티션
키 파티션과 거의 동일하며, MD5함수를 이용해 해시값을 계산하고 분배하는 점이 차이점이다.
PK or UK가 필수적으로 사용되어야 하며, 정수 타입이 아니여도 키 파티션으로 사용 가능하다.