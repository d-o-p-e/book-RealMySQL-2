
## 14.2 스토어드 프로그램의 문법
### 14.2.2 스토어드 프로시저
Q. 건환 스토어드 프로시저란 서로 데이터를 주고받아야 하는 여러 쿼리를 하나의 그룹으로 묶어서 () 으로 실행 하기 위해 사용하는 것이다.
> 독립적

Q. 건환 스토어드 프로시저와 스토어드 함수의 차이는?
> 리턴값 유무, 스토어드 함수는
> SQL 문장의 일부로 사용할 수 있음.

### 14.2.4 트리거
Q. 건환 트리거란 레코드가 ()되거나 ()될 때 미리 정의해둔 작업을 자동으로 실행해주는 스토어드 프로그램이다.
> 저장, 변경

Q. 건환 바이너리 로그 포맷(ROW, STATEMENT) 에 따른 트리거의 동작방식 차이는 ?
> 바이너리 로그 포맷이 ROW일 경우에는 복제서버에 트리거가 기동되지 않지만, STATEMENT의 경우 복제서버에서 트리거가 기동된다.

### 14.2.5 이벤트
> 민우 `ON COMPLETION PRESERVE` 구문으로 인해 이벤트가 삭제되지 않은 상황애서 동일한 이벤트를 실행하면 어떻게 될까?
>
- `Event 설정한_이벤트이름 already exists` 라는 에러와 함께 실행되지 않는다.
- 따라서, 다시 사용할거 같으면 이벤트를 삭제 후 실행하거나, 다른 이름으로 실행해야 된다.

```sql
-- 이벤트 삭제
DROP EVENT 이벤트_명;
```

Q. 건환 주어신 특정한 시간에 스토어드 프로그램을 실행 할 수 있는 스케줄러 기능을 () 라고 한다.
> 이벤트

Q. 건환 ENABLE 상태의 이벤트가 생성되어 있을 때 레플리카 서버가 소스서버로 승격 될 경우 수동으로 이벤트의 상태를 ENABLE 상태로 변경해야 한다.(O/X)
> O

### 14.2.6 스토어드 프로그램 본문(Body) 작성
Q. 건환 SQLSTATE와 에러 번호(Error No) 의 차이는? 
> 에러 번호 : 4가지 숫자로 구성되고, MySQL에서만 유효한 에러 식별코드

> SQLSTATE : 다섯글자의 알파벳과 숫자로 구성되며, 에러뿐만 아니라 여러 상태를 의미한다. 그리고 표준값이므로 특정 벤더에 의존적이지 않다.

Q. 건환 핸들러란 ? 
> 스토어드 프로그램에서 에러나 예외를 처리하는 기능

Q. 건환 핸들러 생성 구문은 다음과 같다.
DECLARE (1. handler_type) HANDLER
FOR (2. condition_value) [, condition_value] ...
(3. handler_statements)
여기서 1, 2, 3번을 간단히 설명하시오

> 1. handler_type : 핸들러의 유형을 지정하는 부분
> 2. condition_value : 핸들러가 작동할 조건을 지정하는 부분
> 3. handler_statements : 핸들러가 실행될 때 처리될 SQL 문장들을 지정하는 부분

Q. 건환 Handler_type 에서 EXIT과 CONTINUE의 차이는?
> EXIT : 현재 핸들러가 최상위 BEGIN…END 블록에 정의됐다면 현재 스토어드 프로그램을 벗어나서 종료

> CONTINUE : handler_statements를 실행하고 스토어드 프로그램의 마지막 실행 지점으로 다시 돌아가 나머지 코드를 처리

Q. 건환 SIGNAL 이란 ?
> 스토어드 프로그램에서 예외를 강제로 발생시키는 데 사용되는 명령문

Q. 건환 커서는 센서티브 커서와 인센서티브 커서로 나눌 수 있다. 두 가지의 차이는?
> 센서티브 커서 : 일치하는 레코드에 대한 정보를 실제 레코드의 포인터만으로 유지하는 형태
> 인센서티브 커서 : 일치하는 레코드를 별도의 임시 테이블로 복사해서 가지고 있는 형태

> 민우 어떤 조건(이벤트)이 발생해서 핸들러를 실행 시킬 때 단순 에러코드만 적혀있으면 가독성이 떨어지므로 컨디션 이름을 부여해서 가독성을 좋게 할 수 있다.  
> 컨디션 이름은 사용자가 지정해서 사용하면 되는데, MySQL의 에러 번호로 `condition_value` 를 지정할 때 에러 코드를 여러 개 동시에 명시할 수 있을까? (o / x) (333p)
>
- x : `CONDITION`을 정의할 때는 에러 코드의 값을 여러 개 동시에 명시할 수 없다.

> 민우 `SQLSTAE` 에서 `00`, `01`, `그 외` 이 세 가지는 어떤 의미를 가질까? (337p)
>
- `00` : 정상 처리(Success)
- `01` : 처리 중 경고 (Warning)
- `그 외` : 처리 중 오류 발생(Error)

> 스토어드 프로그램에서 `변수`, `CONDITION`, `CURSOR`, `HANDLER` 모두 `DECLARE` 명령으로 선언되는데, 정의할 때 어떤 순서로 정의해야 될까? (342p)
>
1. `로컬 변수`와 `CONDITION`
2. `CURSOR`
3. `HANDLER`
- 순으로 정의해야 한다.

### 14.3.1 스토어드 프로그램의 보안 옵션
Q. 건환 스토어드 프로그램을 실행할 때 권한과 관련되어 SQL SECURITY 옵션의 DEFINER와 INVOKER가 있다. 두 가지의 차이는?
> DEFINER : DEFINER로 지정된 사용자의 권한으로 실행
> INVOKER : 호출한 사용자의 권한으로 실행됩니다.

### 14.3.2 DETERMINISTIC 옵션과 NOT DETERMINISTIC
Q. 건환 DETERMINISTIC 옵션과 NOT DETERMINISTIC 옵션의 차이는 ?
> DETERMINISTIC 옵션 : 스토어드 프로그램의 입력이 같다면 시점이나 상황에 관계없이 결과가 항상 같다.
> NOT DETERMINISTIC 옵션 : 시점이나 상황에 따라 결과가 바뀔 수 있다.

> 민우 `DETERMINISTIC`과 `NON DETERMINISTIC` 옵션은 성능과 관련된 옵션이다. \
> 스토어드 프로시저는 일회성으로 실행되기 때문에 이 옵션의 영향을 거의 안 받는데, 스토어드 함수는 영향을 받는다. \
> 이와 관련해서 `DETERMINISTIC`과 `NON DETERMINISTIC` 차이점은 무엇이고, 스토어드 함수를 작성할 때 두 옵션 중 기본 값은 어떤 것일까? (346p)
>
- `DETERMINISTIC`은 딱 한 번만 스토어드 함수를 호출하고, 함수의 결괏값을 상수화해서 쿼리를 실행한다. 
- `NON DETERMINISTIC` 은 WHERE 절이 비교를 수행하는 레코드마다 매번 값이 재평가돼야 한다. (입력값이 같더라도 시점에 따라 스토어드 함수의 결과가 달라질 수 있다)
- 따라서 `NON DETERMINISTIC` 은 절대 상수가 될 수 없다. (테이블 풀 스캔이 일어남)
  `DETERMINISTIC` 은 상수로 사용할 수 있다. (레인지 스캔 가능)
- 스토어드 함수를 작성할 때 두 옵션을 명시하지 않았을 때 기본 값은 `NON DETERMINISTIC`으로 설정 되므로 `DETERMINISTIC` 옵션을 명시해서 사용해야 한다. \
 그러다 **꼭 필요한 순간** `NON DETERMINISTIC`을 적용하면 된다.

### 14.4.2 스토어드 프로그램과 세션 변수
Q. 건환 변수 설정에서 DECLARE와 @ 로 시작하는 사용자변수의 차이는?
> DECLARE : 정확한 타입과 길이 명시해야함.
> @ : 타입을 지정하지 않고 사용 가능함.
