블로그에 작성

https://kihyun-log.tistory.com/entry/Real-MySQL2-Ch11-%EC%BF%BC%EB%A6%AC-%EC%9E%91%EC%84%B1-%EB%B0%8F-%EC%B5%9C%EC%A0%81%ED%99%94

쿼리 작성과 연관된 시스템 변수
SQL모드
STRICT_ALL_TALBES & STRICG_TRANS_TABLES
타입이 적절히 변하거나 값의 길이가 칼럼의 ㅚ대 길이보다 큰 경우 MySQL서버가 INSERT/UPDATE를 수행하지 않도록 하는 설정 값
11.1.2 영문 대소문자 구분
MySQL서버가 운영체제와 관계없이 대소문자 구분의 영향을 받지 않게 하려면, MySQL서버의 lower_case_table_names 시스템 변수를 설정하면 된다 .
11.3.1.1 문자열
MySQL에서는 역따움표(`)로 감싸서 예약어와의 충돌을 피할수 있다(order
전체적으로 MySQL서버의 고유한 방법을 배제하고 SQL 표준 표기법만 사용할 수 있게 강제하려면 sql_mode 시스템ㅂ 변수값에 ‘ANSI’를 설정하면 된다. 하지만 이 설정은 대부분 쿼리의 작동 방식에 영향을 미치므로 프로젝트 초기에 적용하는 것이 좋다. 운용중인 어ㅓ플리케이션에서 sql_mode 설정을 변경하는 것은 상당히 위험하다
11.3.1.2 숫자
MySQL은 문자열 칼럼을 숫자로 변환해서 비교한다. 즉 striang 컬럼의 모든 문자열 값은 숫자로 변환해서 비교를 수행해야 하므로, string컬럼에 인덱스가 있더라도 이를 이용하지 못한다.
11.3.2.7 LIKE 연산자
REGEXP 연산자는 인덱스를 전혀 사용하지 못한다는 단점이 있지만, LIKE 연산자는 인덱스를 ㅇ이용해 처리할 수도 있다.
꼭 필요할때가 아니라면 SYSDATE 함수를 사용하지 않는 편이 좋다, 이미 사용중이라면 sysdate-is-now 시스템 변수를 넣어서 활성화하는 것이 문제점을 제거하는 빠른 방법이다.
[11.4 ] SELECT
MySQL의 LIMIT은 오라클의 ROWNUM과 성격이 조금 달라서 WHERE 조건으로 사용하지 않고 항상 모든 처리의 결과에 대해 레코드 건수를 제한하는 형태로 사용한다.
11.4.2.1 인덱스를 사용하기 위한 기본 규칙
WHERE / ORDER BY 혹은 GROUP BY가 인덱스를 사용하려면 기본적으로 인덱스된 컬러ㅓㅁ의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다.
MySQL 옵티마이저는 인덱스를 최적으로 이용할 수 있게 표현식을 변환하지는 못한다.
결론적으로 인덱스의 컬럼을 변형해서 비교하는 경우에는 인덱스를 이용할 수 없다.
비교도ㅚ는 문자열 타입(varchar / int) 이 다를 때 옵티마이저가 내부적으로 문자열 타입을 숫자 타입으로 변환 후 비교작업을 수행한다.
저장하고자 하는 값의 타입에 맞춰 칼럼의 타입을 설정하고, SQL을 작성할 때는 데이터의 타입에 맞춰서 비교 조건을 사용해야 한다.
11.4.2.2 WHERE절의 인덱스 사용
MySQL8.0부터ㅓ는 인덱스를 구성하는 컬럼별로 오름차순과 내림차순 정렬을 혼합해서 생성할 수 있다.
11.4.2.3 GROUP BY절의 인덱스 사용
인덱스를 구성하는 컬럼 중에서 뒤쪽에 있는 칼럼은 GROUP BY절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스의 앞쪽에 있는 컬럼이 GROUP BY절에 명시도ㅚ지 않으면 인덱스를 사용할 수 없다.
WHERE 조건절과는 달리 GROUP BY절에 명시된 컬럼이 하나라도 인덱스에 없으면 GROUP BY절은 인덱스를 전혀 이용하지 못한다.
11.3.2.4 ORDER BY절의 인덱스 사용
order by 와 group by는 처리 방법이 상당히 비슷하다. 하지만 order by는 조건이 하나 더 있는데 정렬되는 각 컬럼의 오름 차순 및 내림차순 옵션이 인덱스와 같거나 정 반대여야만 인덱스를 사용 할 수 있다.