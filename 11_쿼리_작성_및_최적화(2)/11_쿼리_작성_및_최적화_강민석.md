블로그에 작성

https://velog.io/@minstone/Real-MySQL8.0-11.-%EC%BF%BC%EB%A6%AC-%EC%9E%91%EC%84%B1-%EB%B0%8F-%EC%B5%9C%EC%A0%81%ED%99%942

11.4.4 DISTINCT
특정 컬럼의 유니크한 값을 조회하기 위해 사용.
Q. SELECT DISTINCT(COLUMN1), COLUMN2를 사용할 경우, COLUMN1, COLUMN2 두 열의 고유한 값을 반환한다. (O / X)

A. (O)


11.4.5 LIMIT n
쿼리 결과의 지정된 순서를 가져오기 위해 사용하며 쿼리의 가장 마지막이 실행된다.
GROUP BY는 그루핑과 정렬의 특성을 모두 가지고 있어 인덱스가 없다면, LIMIT절이 있더라도 작업내용을 크게 줄여주지 못한다.
GROUP BY, ORDER BY 절의 경우도 인덱스를 적절히 사용가능한 경우에는 LIMIT 절의 효과를 기대 할 수 있다.
LIMIT 절의 효과를 보기 위해서는 정렬에 대한 요건 없이 유니크한 그룹을 만들어내면 된다.

11.4.6 COUNT()
아스타리스크를 사용한 표현 COUNT(*)을 사용하더라도 PK컬럼을 지정한 것과 동일한 성능을 낸다.
MySQL8.0 버전부터 COUNT() 쿼리에 사용된 옵티마이저가 ORDER BY절을 무시하도록 개선되었다.
COUNT(COLUMN1)의 경우 NULL을 제외하고 카운팅하기에 의도대로 동작하는지 확인이 필요 할 수 있다.
Q. InnoDB 스토리지 엔진에서도 WHERE절이 없는 경우 COUNT(*) 표현식을 즉시 반환한다. (O / X)

A. (X)
InnoDB는 불가하며, MYISAM 스토리지엔진의 경우 테이블에 레코드건수를 메타데이터로 저장 해 WHERE절 없는 조건에서 바로 결과를 반환 할 수 있다.


11.4.7.1 JOIN의 순서와 인덱스
인덱스 레인지 스캔은 인덱스 탑색과 인덱스를 스캔하는 과정으로 구분 할 수 있다.
형이 같은 컬럼비교에서 한쪽 테이블에만 인덱스가 있는 경우 인덱스 있는 테이블을 드리븐 테이블로 선택 할 확률이 높다.
비교 되는 컬럼 모두 인덱스가 없다면, 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 훨씬 효율적이다.

11.4.7.2 JOIN 컬럼의 데이터 타입
데이터 타입이 다른경우, 문자타입이 같더라도 콜레이션이 다른경우, 같은 INT타입이더라도 부호의 존재여부가 다른경우 형변환 작업으로 인덱스를 제대로 사용 할 수 없다.

11.4.7.5 지연된 조인
조인이 실행되기 전에 GROUP BY나 ORDER BY를 처리하는 방식을 지연된 조인이라 한다.
지연된 조인은 LIMIT 절과 사용시 큰 효과를 기대 할 수 있다.
지연된 조인은 조인의 개수를 줄이고 GROUP BY 나 ORDER BY 처리가 필요한 레코드 전체크기를 줄이는 역할도 한다.

11.4.7.6 래터럴 조인
MySQL8.0 버전부터 래터럴 조인이 가능하며, 특정 그룹별로 서브쿼리를 실행해 그 결과와 조인하는 것이 가능하다.
래터럴 조인은 FROM절에서 사용된 서브쿼리에서 외부 쿼리의 FROM절에 정의된 테이블 컬럼을 참조 할 수 있다.
LATERAL 키워드를 사용하지 않으면 에러가 발생하며, 레코드단위로 임시테이블이 생성되기에 필요한 경우에만 사용해야한다.

11.4.7.7 실행계획으로 인한 정렬 흐트러짐
MySQL8.0 버전부터 해시조인을 지원하며, 해시조인 시 인덱스여부에 상관없이 쿼리 결과의 레코드 정렬 순서가 달라진다.
보통 레코드가 반복적으로 순환되는 결과를 반환하며, 인덱스의 정렬을 믿고 order by절을 생략하는 일은 지양해야한다.

11.4.8.1 WITH ROLLUP
그룹별로 소계를 출력하는 레코드가 추가되어 표시된다.
GROUP BY 절에 여러개의 컬럼이 있을경우 각 컬럼별 소계도 반환한다.
Q. 소계항목이 NULL로 표시되는데, 해당컬럼의 내용의 사용자화가 가능하다. (O / X)

A. (O)
MySQL8.0 버전부터 레코드에 표시되는 NULL을 사용자화 할 수있는 GROUPING() 함수를 지원한다.


11.4.8.2.1 레코드를 컬럼으로 변환
엑셀의 피벗기능과 동일한 개념이다.
GROUP BY쿼리의 결과를 CASE - WHEN과 같은 구문을 사용해 한번더 변환하는 과정을 거쳐 사용해 볼 수 있다.

11.4.9 ORDER BY
인덱스를 사용한 SELECT의 경우에는 인덱스에 정렬된 순서대로 레코드를 가져온다.
SEELCT 쿼리가 임시테이블을 거쳐 처리되면, 조회되는 레코드의 순서를 예측하기 어렵다.
어떤 DBMS도 ORDER BY절이 없다면, 쿼리에 대해 어떠한 정렬도 보장하지 않는다.
ORDER BY 절 사용 시 실행계획에서 Using filesort를 확인하는 경우가 있으며 이경우 sort-merge 작업이 발생한다.

소트머지 수행과정이며 sort_buffer_size 사이즈를 조절해 디스크 접근을 최소화 해야한다.
Q. InnoDB, MYISAM 모두 삽입된 순서대로 정렬된다. (O / X)

A. (X)
MYISAM 스토리지엔진의 경우 레코드가 삭제되면 빈공간에 레코드가 삽입 될 수 있어, INSERT된 순서로 정렬되지 않았을 수 있다.


11.4.9.2 여러 방향으로 동시 정렬, 11.4.9.3 함수나 표현식을 이용한 정렬
MySQL8.0 버전부터 오름차순과 내림차순을 혼용해 복합인덱스를 생성 할 수 있다.
함수를 사용한 연산값 기준으로 정렬하는 작업이 인덱스를 사용하도록 개선되었다.

11.4.10.1 SELECT절에 사용된 서브쿼리
임시테이블을 만들거나 쿼리를 비효율적으로 실행하게 만들지 않기에 인덱스를 잘사용하는지 여부만 체크하면된다.
SELECT절에 서브쿼리를 사용하면 항상 컬럼과 레코드가 하나인결과를 반환해야 한다. -> 스칼라 서브쿼리
Q. SELECT절에 서브쿼리를 사용할 때 처리속도 개선방안은 무엇인가? (O / X)

A. SELCT절 서브쿼리보다 조인이 처리속도가 더 빠르므로 가능하면 조인으로 쿼리를 작성한다.


11.4.10.2 FROM절에 사용된 서브쿼리
5.7버전부터 FROM절에 서브쿼리가 사용되면, 옵티마이저가 서브쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 개선되었다.
Q. FROM절에 서브쿼리를 사용할 때 병합이 불가능한 경우가 있다. (O / X)

A. (O)
집단함수, DISTINCT, GROUP BY, LIMIT 등 회부쿼리로 병합하지 못하는 경우가 존재한다.


11.4.10.3 WHERE절에 사용된 서브쿼리
동등및 크다 작다 비교에서 MySQL5.5 버전부터 서브쿼리를 먼저 실행한 후 나머지 쿼리부분을 처리한다.
IN 비교에서는 세미조인을 수행하며 세미조인이랑 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식과 일치하는지 체크하는 형태를 말한다.
NOT IN 비교의 경우 인덱스를 제대로 활용 할 수 있으며 NOT EXISTS, 구체화 두가지 방법으로 최적화를 수행할 수 있다.
NOT IN절만 단독으로 사용된경우 테이블 풀스캔을 한다.

11.4.11 CTE
임시테이블의 종류로 SQL 문장 내에서 한번이상 사용 될 수 있으며, SQL문장이 종료되면 자동으로 삭제된다.
ANSI 표준으로 WITH절을 이용해 CTE를 정의 할 수 있다.
CTE 임시 테이블은 재사용 가능하므로 FROM절의 서브쿼리보다 효율적이다.
Q. CTE로 생성된 임시 테이블은 다른 CTE쿼리에서 참조할 수 없다. (O / X)

A. (X)
CTE로 생성된 임시테이블은 다른 CTE쿼리에서 참조할 수 있다.


11.4.12 윈도우 함수
조회하는 현재 레코드를 기준으로 연관된 레코드 집합의 연산을 수행한다.
집계함수는 하나의 레코드로 묶어 출력하지만, 윈도우함수는 레코드수는 변하지 않고 출력한다.
FROM, WHERE, GROUP BY, HAVING -> 윈도우 함수 -> SELECT, ORDERBY, LIMIT . 그룹순서로 실행된다.
MySQL 서버의 윈도우 함수에는 집계 | 비집계 함수를 모두 사용 할 수 있다.
MySQL8.0 버전에 처음 도입됐으며, 인덱스를 이용한 최적화가 부족한 부분도 있다.

11.4.13 잠금을 사용하는 SELECT
InnoDB 테이블은 SELECT작업에 잠금을 사용하지 않는다.
강제로 잠금이 필요한 경우 FOR SHARE와 FOR UPDATE 절을 이용 할 수 있다.
FOR SHARE 절은 SELECT된 레코드에 대해 읽기잠금을 설정하고, 다른 세션은 읽기는 가능하나 레코드변경을 제한한다.
FOR UPDATE 절은 배타잠금을 획득하고, 레코드 변경 및 읽기가 가능하다.

11.4.13.2 NOWAIT & SKIP LOCKED
NOWAIT 옵션은 다른 트랜잭션에 의해 잠겨진 상태라면 에러를 반환하며 쿼리는 즉시 종료된다.
SKIP LOCKED 옵션은 다른 트랜잭션에 의해 잠겨진 상태라면 잠겨지지 않은 레코드만 가져온다.