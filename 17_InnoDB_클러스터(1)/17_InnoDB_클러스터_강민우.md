---

### 17.1 - InnoDB 클러스터 아키텍처

> InnoDB 클러스터로 구성된 그룹 복제에서 프라이머리는 하나만 존재할 수 있다? (o / x) (558p)
>
> - x : 그룹 복제에 설정된 모드에 따라 프라이머리는 하나만 존재할 수도 있고 여러 대가 존재할 수도 있다.

> InnoDB 클러스터로 구성된 그룹 복제에서 InnoDB 스토리지 엔진만 사용할 수 있을까? (o / x) (558p)
>
> - o : 그룹 복제에서는 InnoDB 스토리지 엔진만 사용할 수 있다.
> - 이것이 InnoDB 클러스터라고 명명된 이유이다.

> InnoDB 클러스터로 그룹 복제를 구성할 때 고가용성을 위해 MySQL 서버를 최소 몇 대 이상으로 구성하는 것이 좋을까? (558p) <br>
>
> - 최소 3대 이상은 구성해야 한다.
> - 3대로 구성했을 때부터 서버 한 대에 장애가 발생하더라도 복제 그룹이 정상적으로 동작하기 때문

### 17.2 - 그룹 복제 (Group Replication)

> 그룹 복제에서 트랜잭션 커밋을 처리할 때 과반수 이상의 멤버로부터 응답을 받지 못하면 해당 트랜잭션은 어떻게 될까? (561p)
>
> - 과반수 이상의 멤버로부터 응답을 받지 못한 트랜잭션은 그룹에 적용되지 않는다.
> - 이 부분으로 인해 기존 복제의 반동기 방식과는 다르다.
  >     - 반동기 방식에서는 과반수 이상의 멤버로부터 응답을 받았나 못 받았나를 검사하지 않는다.
  >     - 또한, 기존 반동기에서는 소스 서버가 레플리카 서버로부터 응답을 못 받았다고 해서 해당 트랜잭션이 소스 서버에 적용되지 않는것은 아니였지만, \
  >   그룹 복제에서는 **그룹 내 멤버들로부터 응답 결과에 따라서 결과가 달라진다**는 점이 차이점이다. (~~소스 서버에서 적용되지 않을 수도 있다는 뜻인가?~~)

> 클러스터링으로 구성된 그룹 복제에서 데이터를 조회하는 쿼리가 날라왔을 때 합의(Consensus)과정을 거칠까? (o / x) (561p)
>
> - x : 데이터를 읽기만 하는 트랜잭션에 대해서는 consensus 과정이 필요하지 않다. (변경에선 필요함)

> 트랜잭션 인증의 역할은?
>
> - 트랜잭션 인증은 인증 대상 트랜잭션이 이미 인증 단계를 통과한 선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 \
> 충돌 여부를 검사해서 문제없이 적용 가능한지를 확인하는 과정이다.

### 17.2.1 - 그룹 복제 아키텍처

> 그룹 복제를 구성할 때 MySQL 서버의 수를 어떻게 계산해야 할까? (564p)
>
> - 그룹 복제에서 복제를 처리할 때 정상적으로 동작하려면 그룹 멤버들 간에 합의(Consensus) 절차가 수행되므로 \
> 정상적으로 동작하려면 **과반수에 해당하는 서버가 정상적으로 동작**해야 한다.
> - 따라서 `n = 2f + 1` 의 서버로 구성해야 된다. (`n` : 전체 서버 수, `f` : 허용 가능한 장애 서버 수)

### 17.2.2.1 - 싱글 프라이머리 모드

> 싱글 프라이머리 모드란 무엇일까? (565p)
>
> - 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태이다.

> 그룹의 특정 프라이머리를 지정하지 않을 경우 어떤 기준을 바탕으로 새로운 프라이머리를 선출하게 될까? (566p)
>
> 1. MySQL 서버 버전이 가장 낮은 멤버를 선출한다. (버전이 가장 낮은 멤버를 찾기위해 정렬을 수행한다.)
  >   1. 모든 멤버가 8.0.17 이상의 버전을 사용중인 경우 패치 버전을 기준으로 정렬
>     2. 8.0.17 미만의 버전일 경우 메이저 버전을 기준으로 정렬된다.
> 2. 가장 낮은 멤버가 둘 이상일 경우 각 멤버의 가중치 값을 비교한다. (가중치가 높은 값을 선택한다.)
  >   1. 가중치를 확인하기 위해 `replication_member_weight` 변수를 활용하는데 이 변수는 5.7.20 버전부터 도입됐으므로 그 이하의 버전을 사용할 경우 무시된다.
> 3. UUID 값의 사전식 순서
  >   1. `server_uuid` 의 사전식 순서로 해당 값이 가장 낮은 멤버를 새로운 프라이머리로 최종 선택된다.

> 다음과 같은 멤버로 구성되어 있고, 특정 프라이머리를 지정하지 않았을 경우 어떤 멤버가 프라이머리로 선택될까? 모든 멤버의 MySQL 버전은 8.0.17로 동일하다. ([출처](https://hoing.io/archives/5006#_Primary))
>
> 1. `member-1: group_replication_member_weight=30, server_uuid=aaaa`
> 2. `member-2: group_replication_member_weight=40, server_uuid=bbbb`
> 3. `member-3: group_replication_member_weight=40, server_uuid=cccc`
> 4. `member-4: group_replication_member_weight=40, server_uuid=dddd`
>
> - `member-2`가 프라이머리로 선정된다.

### 17.2.2.2 - 멀티 프라이머리 모드

> **멀티 프라이머리 모드**를 사용하는 그룹 복제에서 다음과 같은 멤버들이 그룹에 참여하려고 하는데 참여할 수 있는 멤버는 몇 번일까? \
> 기존 그룹 복제에서 가장 낮은 MySQL 버전은 8.0.20 이다. (568p)
>
> 1. `member-1: MySQL Version = 8.0.18`
> 2. `member-2: MySQL Version = 8.0.19`
> 3. `member-3: MySQL Version = 8.0.21`
> 4. `member-4: MySQL Version = 8.0.20`
>
> - `3`, `4` 번만 참여가 가능하다. 버전에 따른 호환성 검사로 인해 `1`, `2` 번은 참여할 수 없다. \
    단, `3`번은 **읽기 전용 모드를 유지**한다.
> - 호환성 검사의 기준은 다음과 같다.
  >   - 그룹에 존재하는 가장 낮은 MySQL 버전보다 **낮은 버전을 사용 중인 경우 그룹에 참여할 수 없다**.
>     - 그룹에 존재하는 가장 낮은 MySQL 버전과 **동일한 버전을 사용하면 참여할 수 있다**.
>     - **멀티 프라이머리 모드**의 그룹에서는 새로운 멤버가 그룹에 존재하는 \
>     **가장 낮은 MySQL 버전보다 높은 버전을 사용할 경우** 그룹에 참여할 수는 있지만, **읽기 전용 모드를 유지**하게 된다.
>     - **싱글 프라이머리 모드**로 설정된 그룹에서는 **버전에 상관없이 새로 참여하는 멤버는 항상 읽기 전용 모드**로 설정된다.
> - 단, 기존 그룹 멤버들과 버전을 비교할 때는 사용 중인 MySQL 버전에 따라 비교 범위가 달라진다.
  >   - 새로운 멤버가 8.0.17 이상의 버전을 사용 중인 경우 기존 그룹 멤버들의 패치 버전까지 고려하고
  >   - 8.0.17 미만의 버전을 사용 중인 경우엔 기존 그룹 멤버들의 메이저 버전을 비교하게 된다.

> 여러 그룹 멤버들에서 실행된 트랜잭션들에 대한 충돌이 싱글 프라이머리 모드에서 발생할까? (o/x) (572p)
>
> - x : 트랜잭션 충돌은 그룹 멤버 전체가 쓰기를 처리할 수 있는 멀티 프라이머리 모드에서만 발생하고, \
    싱글 프라이머리에선 발생하지 않는다.

### 17.2.4.1 - 트랜잭션 일관성 수준

> 그룹 복제에서 한 멤버에게 쓰기를 수행한 후 바로 다른 멤버에서 해당 데이터를 읽었을 때, \
> 프라이머리 장애로 인해 페일오버가 발생하는 경우 **최신 변경 사항이 반영되지 않은 상황**이 발생할 수 있다. \
> 이런 상황을 어떻게 방지할 수 있을까? (574p)
>
> - 만약, MySQL 버전이 8.0.14 이전이라면 방지할 수 있는 방법이 없다.
> - 8.0.14 버전 이후라면 위 같은 상황에서 `group_replication_consistency` 변수를 활용해서 **트랜잭션 일관성**을 적용해 방지할 수 있다.
  >     - `group_replication_consistency` 변수의 적용 범위로는 글로벌 또는 세션 모두 가능하다.

> `group_replication_consistency` 변수에 설정 가능한 일관성 수준의 종류는 무엇이 있을까? (574p)
>
> - `EVENTUAL`, `BEFORE_ON_PRIMARY_FAILOVER`, `BEFORE`, `AFTER`, `BEFORE_AND_AFTER` 각각의 일관성 수준이 존재한다.

### 일관성 수준들에 대해 간략한 설명

- `EVENTUAL` (574p)
    - 읽기 전용 및 읽기-쓰기 트랜잭션이 별도 제약 없이 바로 실행 가능.
    - 위에서 본 **최신 변경 사항이 반영되지 않는 상황이 발생**한다.
- `BEFORE_ON_PRIMARY_FAILOVER` (575p)
    - 싱글 프라이머리 모드로 설정된 그룹 복제에서 프라이머리 페일 오버가 발생해 신규 프라이머리가 선출됐을 때만 트랜잭션 일관성을 부여한다.
    - 즉, 새로운 프라이머리로 유입된 트랜잭션은 이전 프라이머리의 트랜잭션이 모두 적용될 때까지 처리되지 못하고 대기하게 된다.
    - 하지만 프라이머리 페일오버가 발생하지 않는 상황엔 `EVENTUAL` 일관성 수준으로 처리된다.
- `BEFORE` (577p)
    - 페일오버와 상관없이 읽기 및 읽기-쓰기 모두 선행 트랜잭션이 완료될 때까지 대기 후 처리된다.
    - 선행 트랜잭션이란 해당 트랜잭션이 실행된 그룹 멤버에서의 선행 트랜잭션만을 의미한다. (전체 그룹 x)
    - DB에서 읽기 요청보다 쓰기 요청이 많은 경우에 사용하는 것이 좋다.
- `AFTER` (578p)
    - 트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 한다.
    - 즉, 읽기-쓰기 트랜잭션이 들어올 때 다른 모든 멤버들에서도 해당 트랜잭션이 커밋될 준비가 될 때까지 대기한 후 처리한다.
    - 읽기 전용 트랜잭션은 데이터 변경을 발생시키지 않으므로 별도의 제약 없이 바로 처리된다.
    - DB에서 쓰기 요청보다 읽기 요청이 많은 경우에 사용하는 것이 좋다.
- `BEFORE_AND_AFTER` (579p)
    - `BEFORE` 수준과 `AFTER` 수준이 결합된 형태이다.
    - 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 기다린 후 실행되며, \
      트랜잭션이 다른 모든 멤버들에서도 커밋이 준비되어 응답을 보내면 그때 최종적으로 커밋
    - 읽기 전용 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 대기한 후 실행

### 17.2.4.1.2 - `BEFORE_ON_PRIMARY_FAILOVER` 일관성 수준

> `BEFORE_ON_PRIMARY_FAILOVER` 일관성 수준을 사용할 때 읽기-쓰기 모두 이전 프라이머리의 트랜잭션을 적용하고 있는 경우 \
> 해당 트랜잭션들이 처리될 때까지 신규 프라이머리에선 대기하게 된다. \
> 근데, 대기하지 않고 즉시 실행할 수 있는 쿼리들이 존재하는데 무엇일까?
>
> - 서버 모니터링을 위한 읽기 쿼리는 즉시 실행 가능하다.
  > - 가능한 쿼리로는 다음과 같다. \
    `SHOW`, `SET`, `DO`, `EMPTY`, `USE`, \
    `performance_schema 및 sys 데이터베이스에 대한 SELECT`, \
    `information_schema.PROCESSLIST 테이블에 대한 SELECT`, \
    `테이블 또는 사용자 정의 함수를 사용하지 않는 SELECT`, \
    `STOP GROUP_REPLICATION`, `SHUTDOWN`, `RESET PERSIST` 문이 있다.

### 16.2.4.1.5 - `BEFORE_AND_AFTER` 일관성 수준

> `BEFORE_ON_PRIMARY_FAILOVER`, `BEFORE`, `AFTER`, `BEFORE_AND_AFTER` 이 넷 일관성 수준 모두 동일한 일관성 보장을 제공할까? (o/x)
>
> - o : 모두 다음과 같은 일관성을 보장한다.
   >     - 신규 프라이머리로 유입된 읽기 전용 및 읽기-쓰기 트랜잭션들은 **최신 데이터를 바탕으로 동작**한다.
>     - `BEFORE_ON_PRIMARY_FAILOVER` 일관성 수준을 사용하면 롤백은 발생하지 않게 된다.

### 17.2.4.2 - 흐름 제어 (Flow Control)

> 흐름 제어를 언제 사용할까? (580p)
>
>
>
> - 그룹 복제에서 어떤 멤버가 다른 멤버들보다 하드웨어 스펙이 낮거나, 네트워크 대역폭이 작거나, 부하를 더 많이 받고 있을 때 트랜잭션 적용이 지연된다. 
> - 이로 인해 오래된 데이터를 읽거나, 적용하지 않은 트랜잭션과 충돌하는 일이 발생한다. \
(~~일관성 수준을 이용해 방지할 수 있지만 근본적으로 해결되지 않아 지연이 오래될 경우 일관성 수준으론 해결할 수 없다~~) 
> - 이처럼 **트랜잭션 적용 불균형으로 발생하는 문제를 방지하기 위해 흐름 제어를 사용**하면 좋다.

> 흐름 제어는 어떤 방식을 통해 트랜잭션 적용 불균형을 해결할 수 있을까? (580p)
>
> - 그룹 멤버들의 쓰기 처리량을 조절하는 방식을 통해 트랜잭션 적용 불균형 문제를 해결한다.
  >     - 쓰기 처리량을 조절해서 멤버 간 트랜잭션 갭을 적게 유지한다.
>     - 평소와 다른 워크로드가 유입되는 등의 변화에도 멤버들의 쓰기 처리량을 균등하게 할 수 있다.

> 어떻게 흐름 제어를 사용할 수 있을까? (580p)
>
> - `group_replication_flow_control_mode` 변수를 통해 흐름 제어 기능을 사용할 수 있다.
  >     - `QUOTA` 모드 `DISABLED` 두 모드밖에 없다. ([23.08.25 동일](https://dev.mysql.com/doc/refman/8.0/en/group-replication-system-variables.html#sysvar_group_replication_flow_control_mode))

> 흐름 제어는 그룹 전반에 걸쳐 동기화된 형태로 동작할까? (o/x) (581p)
>
> - x : 각 멤버에서 개별적으로 수행된다.

> 멤버에서 흐름 제어 주기를 설정할 때 주의해야 될 사항으로 무엇이 있을까? (581p)
>
> - 다른 멤버들보다 10배 더 큰 값으로 주기를 설정하면 일부 주기에서 무시될 수 있으므로 주의해야한다.

> 흐름 제어에서 멤버에게 할당할 쓰기 처리량을 계산하는 로직 (583p)
>
> 1. 통계 정보를 바탕으로 계산된 값, `group_replication_flow_control_min_quota` 변수의 값 중 큰 값을 선택. \
   (**복구 중인 멤버**가 있으면 `group_replication_flow_control_min_recovery_quota` 사용)
> 2. `1`에서 결정된 값 * (100 - `group_replication_flow_control_hold_percent`)
> 3. `group_replication_flow_control_max_quota` 값이 0보다 크면 \
      `2`번의 값과, `group_replication_flow_control_max_quota` 값 중 더 작은 값 선택
> 4. 쓰기를 처리하는 멤버의 수가 둘 이상 존재하는 경우 추가적인 로직 발생
  >     1. `group_replication_flow_control_member_quota_percent` 값이
>     2. 0인 경우 `3`에서 선택된 값 / 쓰기 멤버 수 (이전 흐름 제어 주기에서 쓰기를 수행한 멤버의 수)
>     3. 0이 아닌 경우 `3` 에서 선택된 값에 `group_replication_flow_control_member_quota_percent` 값을 곱한다.

### 17.2.5 - 그룹 복제의 자동 장애 감지 및 대응

> 장애 감지 및 대응 프로세스는 어떻게 동작할까? (584p)
>
> - 그룹 복제에서 멤버 간에 주기적으로 통신 메시지를 주고받으며 서로의 상태를 확인하는데, \
 `group_replication_member_expel_timeout` 에 설정된 값을 초과할 경우 의심하기 시작하고, \
 과반수의 멤버가 동의하면 해당 멤버를 그룹에서 추방시킨다.
> - `group_replication_member_expel_timeout` 값이 넘었을 때 즉시 추방되는지 아니면 과반수를 계산하는지 잘 모르겠습니다.

### 17.2.6.1 - 분산 복구 방식

> 분산 복구 방식에는 `바이너리 로그 복제 방식`과 `원격 클론 방식` 두 가지 방식은 각각 무엇일까? (589p)
>
> - **바이너리 로그 복제 방식**
  >     - MySQL 기본 복제 방식인 비동기 복제를 기반으로 구현되어 있다.
>     - 기증자로 선택된 다른 그룹 멤버와 별도의 복제 채널로 연결되어 \
>   해당 멤버의 바이너리 로그에서 새로 가입한 멤버에 적용되지 않은 트랜잭션들을 복제해서 가져와 가입한 멤버에 적용하는 방식이다.
>     - 별도의 복제 채널 이름은 `group_replication_recovery` 이다.
> - **원격 클론(Remote Cloning) 방식**
  >     - 8.0.17 버전에서 도입된 클론 플러그인(Clone Plugin)을 사용하는 형태이다.
>     - 다른 그룹 멤버의 InnoDB 스토리지 엔진에 저장된 모든 데이터와 메타데이터를 일관된 스냅샷으로 가져와 가입 멤버를 재구축하는 방식이다.
>     - 이 방식으로 작업을 진행하려면 그룹 멤버들, 가입 멤버 모두 클론 플러그인이 설치되어 있어야 한다

> 그룹 복제 분산 복구에서 가입한 멤버에 대해 적합한 형태의 복구 방식을 자동으로 선택하는데 어떤걸 기준으로 선택할까? (589p)
>
> - `가입한 멤버와 기존 그룹 멤버 간 트랜잭션 갭이 크거나`, `기존 그룹 멤버의 바이너리 로그 파일에서 필요한 트랜잭션이 없을 경우`엔 **원격 클론 방식으로 복구**한다.
  >     - 트랜잭션 갭의 임곗값은 `group_replication_clone_threshold` 변수의 값을 확인하면 된다.
>     - 원격 클론 방식에선 가입한 멤버의 기존 데이터는 모두 제거되며
      >     클론 작업으로 연결된 기존 그룹 멤버의 스냅샷 데이터가 저장된다.
> - `가입한 멤버와 기존 그룹 멤버 간 트랜잭션 갭이 작거나`, `원격 플러그인이 설치돼 있지 않은 경우`엔 **바이너리 로그 복제 방식으로로 복구**한다.

### 17.2.7 - 그룹 복제 요구사항

> 그룹 복제를 사용하려면 어떤 요구사항들을 충족해야 할까?
>
> - **InnoDB 스토리지 엔진을 사용**해야 한다. (트랜잭션 처리를 위해서, 다른 스토리지 엔진 에러 발생)
  >     - `my.cnf` 파일에서 다음과 같이 다른 엔진의 사용을 방지할 수 있다.
  >
  >      ```bash
  >         [mysqld]
  >         disabled_storage_engines=”MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY”
  >         ```
>
> - **프라이머리 키 사용**
  >     - 그룹에서 복제될 모든 테이블들은 프라이머리 키를 가지고 있어야 하며, \
             명시적인 프라이머리 키가 없다면 `NOT NULL + 유니크 키`가 반드시 테이블에 존재해야 한다.
>     - 테이블 내의 모든 데이터에 대해 고유한 식별자 역할 (이를 바탕으로 트랜잭션 간의 충돌 감지)
> - **원활한 네트워크 통신 환경**
  >     - 그룹 멤버들간의 양방향 통신을 하므로 성능과 안정성은 네트워크 환경에 영향을 받는다.
> - **바이너리 로그 활성화**
  >     - 기존 MySQL 복제와 마찬가지로 복제에서 바이너리 로그를 사용하므로 \
                 바이너리 로그가 활성화 되어 있어야 한다.
>     - 8.0 버전부터 기본적으로 활성화 되어 있다.
> - **ROW 형태의 바이너리 로그 포맷 사용**
  >     - ROW 포맷 기반의 복제를 사용해 트랜잭션으로 변경된 데이터가 \
            >     그룹 멤버들에서 일관되게 적용될 수 있게 한다.
> - **바이너리 로그 체크섬 설정**
  >     - 8.0.20 버전까지 바이너리 로그 체크섬 기능을 지원하지 않아 \
            >     `binlog_checksum` 변수의 값을 NONE으로 설정했지만,
>     - 8.0.21 버전부터 체크섬 기능을 지원하므로 해당 변수에 사용자가 원하는 값을 설정할 수 있다.
> - **log_slave_updates 활성화**
  >     - 새로운 멤버가 그룹에 참여하면 분산 복구 작업을 수행하는데, \
                 이때 기존 그룹 멤버의 바이너리 로그를 복제해서 자신에게 적용하므로 \
                 그룹에서 발생한 트랜잭션들을 모두 각자의 바이너리 로그에 기록해야 한다.
>     - 그룹 복제에서 그룹의 모든 멤버들이 쓰기를 수행하는 서버가 될 수 있으므로 \
             해당 변수가 반드시 활성화 돼야 한다.
> - **GTID 사용**
  >     - 그룹 복제는 기본적으로 GTID를 사용하므로 그룹 복제를 설정할 MySQL 서버에서는 GTID를 활성화 시켜야 한다.
> - **고유한 server_id 사용**
  >     - 복제에 참여하는 서버들은 고유한 server_id 값을 가져야 한다.
> - **복제 메타데이터 저장소 설정**
  >     - 그룹 복제에서 복제 관련 메타데이터는 데이터 일관성을 위해 파일이 아닌 테이블에 저장돼야 한다. \
  >   따라서 master_info_repository 및 relay_log_info_repository 변수의 값이 TABLE로 설정되어 있어야 한다.
> - **트랜잭션 WriteSet 설정**
  >     - 트랜잭션에서 변경한 데이터에 대한 정보, \
                 트랜잭션의 WriteSet이 수집될 수 있도록 transaction_write_set_extraction 변수가 XXHASH64로 설정돼야 한다. \
                 WriteSEt은 그룹 복제에서 트랜잭션 간 충돌을 탐지하는 트랜잭션 인증 단계에서 사용한다.
> - **테이블 스페이스 암호화 설정**
  >     - `default_table_encryption` 변수는 모든 그룹 멤버에서 동일한 값으로 설정돼야 한다.
> - **lower_case_table_names 설정**
  >     - `lower_case_table_names` 변수는 모든 그룹 멤버에서 동일한 값으로 설정돼야 한다.
> - **멀티 스레드 복제 설정**
  >     - 그룹 복제도 멀티 스레드 복제 기능을 사용해 트랜잭션을 병렬로 적용할 수 있다.
>     - 이때 복제 트랜잭션이 멀티 스레드로 적용될 때 \
             원본 서버에서 커밋된 순서와 동일한 순서로 커밋되도록 \
             반드시 slave_preserve_commit_order 옵션을 ON(1)으로 설정해야 한다.
>     - 만약, 멀티 스레드 복제 기능을 사용하고자 한다면 다음과 같이 설정하는 것이 좋다.
> 
>      ```bash
>         [mysqld]
>         slave_parallel_workers=N
>         slave_parallel_type=LOGICAL_CLOCK
>         slave_preserve_commit_order=1
>         ```
>

### 17.2.8 - 그룹 복제 제약 사항

> 그룹 복제 제약 사항은 무엇이 있을까? (598p)
>
- 갭 락(Gap Lock)은 갭 락을 발생시킨 트랜잭션이 실행된 멤버에서만 유효하며,
    - 그룹 복제의 트랜잭션 인증 단계에서 해당 락 정보는 공유되지 않는다.
    - 따라서, 멀티 프라이머리 모드로 동작하는 그룹에서는 \
      멤버 로컬에서의 트랜잭션 충돌 감지와 그룹 복제에서의 트랜잭션 충돌 감지 수준을 일치시키기 위해 \
      갭락이 사용되지 않는 `READ-COMMITTED` 격리 수준을 사용하는 것이 좋다.
- 테이블 락(Table Lock) 및 네임드 락(Named Lock)도 그룹 단위로 락 정보가 공유되지 않는다.
    - 즉, 그룹 복제의 인증 단계에서는 이 두락을 고려하지 않는다.
- 그룹 복제에서 바이너리 로그 체크섬 기능은 8.0.21 버전부터 사용 가능 (그 이전 버전에선 지원하지 않음)
- 멀티 프라이머리 모드로 동작 중인 그룹에서는 `SERIALIZABLE` 격리 수준을 사용할 수 없다.
- 멀티 프라이머리 모드로 동작 중인 그룹에서 동일한 테이블에 대해
  서로 다른 멤버에서 동시에 실행되는 DDL 및 DML 문은 지원하지 않는다.
- 멀티 프라이머리 모드로 동작 중인 그룹에서 외래키(FK)가 존재하는 테이블은 지원하지 않는다.
    - 특히, `CASCADE` 제약 조건이 사용된 테이블은 지원하지 않는다.
    - `CASCADE` 제약 조건은 계단식 데이터 변경 작업을 유발하며, \
      이로 인해 감지되지 않는 트랜잭션 충돌이 발생하고, 그룹 멤버 간에 데이터가 일치하지 않을 수 있다.
    - 따라서 이 같은 문제를 방지하기 위해 멀티 프라이머리 모드 그룹의 멤버들에서 \
      `group_replication_enforce_update_everyshere_checks` 변수를 활성화 하는 것이 좋다.
    - 해당 변수를 활성화 하면 그룹 복제에서는 실행된 쿼리들에 대해 \
      멀티 프라이머리 모드와 호환되지는지 검사한다.
    - 싱글 프라이머리 모드에선 한 멤버에서만 쓰기가 허용되므로 \
      데이터 일관성을 해칠 수 있는 문제는 발생하지 않는다. \
      따라서, 싱글 프라이머리 모드에선 위 변수를 OFF 해놓자.
- 멀티 프라이머리 모드에서 `SELECT ... FRO UPDATE` 구문을 사용할 때 데드락이 발생할 수 있다.
- 그룹 복제에서 복제 필터 기능은 사용할 수 없다.
    - 그룹 멤버가 그룹 외부의 다른 소스 서버에 대한 일반 복제도 함께 진행하는 경우
      일반 복제에 대한 필터링은 적용 가능.
- 그룹 복제는 최대 9대의 서버까지 구성 가능하다.
    - 이미 9대로 구성된 그룹 복제에서 새로 멤버가 추가되는 경우에는 에러가 발생한다.

## InnoDB 클러스터 도커로 구성할 때 참고

- MySQL 공식 - [https://dev.mysql.com/blog-archive/docker-compose-setup-for-innodb-cluster](https://dev.mysql.com/blog-archive/docker-compose-setup-for-innodb-cluster/)