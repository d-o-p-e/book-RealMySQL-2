## 17.2 - 그룹 복제 (Group Replication)
/**
  그룹 복제는 5.7.17 버전에서 도입된 새로운 복제 방식이며, 기존 복제 프레임워크를 기반으로 구현되어 내부적으론
  Row 포맷의 바이너리 로그와 릴레리 로그, GTID를 사용한다.

  기존 복제의 경우 일반적으로 소스-레플리카 형태로 구성되어 단방향으로만 복제가 이뤄지는 반면,
  그룹 복제에서는 복제에 참여한 MySQL 서버들이 하나의 복제 그룹으로 클러스터 형태를 가지며, 그룹 내 서버들은 서로 통신하면서 양방향으로 복제를 처리할 수도 있다.
  즉, 하나의 복제 그룹 내에서 쓰기를 처리하는 서버가 여러 대 존재할 수 있으며,
  그룹 복제에서는 '프라이머리(= 소스)'와 '세컨더리라(= 레플리카)'라는 용어를 사용하고, 복제에 참여하는 MySQL 서버들을 '그룹 멤버'라고 지칭한다.

  기존 복제와 그룹 복제의 다른 차이점으론 복제 처리 방식도 있다.
  기존 복제에서의 복제 처리 방식을 데이터 동기화 측면에서 분류하면 비동기(Asynchronous) 방식과 반동기(Semi-Synchronous) 방식으로 나눌 수 있다.
  그룹 복제에서는 반동기 방식이라고 할 수 있는데, 그렇다고 해서 기존 복제의 반동기랑은 조금 다르다.

  그룹 복제에서도 기존 반동기와 마찬가지고 트랜잭션에 대해 그룹 내 다른 멤버들의 응답을 확인하는 단계가 존재한다.
  한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션 정보를 그룹의 다른 멤버들에 전송하고 과반수 이상의 멤버로부터 응답을 전달받으면
  그때 해당 트랜잭션을 인증(Certify)하고 최종적으로 커밋 처리를 완료한다.
    - 트랜잭션 인증은 인증 대상 트랜잭션이 이미 인증 단계를 통과한 선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 충돌 여부를 검사해서
     문제없이 적용 가능한지를 확인하는 과정이다.

  그룹 복제에서 트랜잭션 커밋을 처리할 때 과반수 이상의 멤버로부터 응답을 받지 못하면 해당 트랜잭션은 그룹에 적용되지 않는다.
  따라서, 트랜잭션이 최초 발생한 서버에서 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들이
  해당 트랜잭션을 실제로 적용했는지까지 확인하는 것은 아니라서 반동기 방식으로 분류할 수 있으나, 기존 복제의 반동기 방식과는 전혀 다른 형태로 동작한다.

  또한, 기존 반동기 방식은 소스 서버가 레플리카 서버로부터 응답을 못 받았다고 해서 트랜잭션이 소스 서버에서 적용되지 않는 것은 아니므로
  기존 복제의 비동기와 반동기 방식 모두 복제 구성 내에서 트랜잭션은 소스 서버에서 일방적으로 적용된다고 할 수 있다.
  그러나, 그룹 복제에서는 그룹 내 멤버들의 응답에 따라 전체 복제 그룹에서 해당 트랜잭션의 적용 여부가 결정되므로
  이러한 부분이 기존 복제와의 가장 큰 차이점이라고 할 수 있다.

  그룹 복제에서 이처럼 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 합의(Consensus)라고 하는데,
  이는 그룹 멤버들로부터 이 트랜잭션을 복제 그룹에 적용하는 것에 대한 동의를 구하는 것이기 때문이다.
  그룹 복제에서는 매 트랜잭션을 처리할 때마다 합의(Consensus) 과정을 반드시 거친다.
    - 데이터를 변경하는 과정에서만 합의(Consensus) 과정을 거치고 단순히 읽기만 하는 트랜잭션들은 합의(Consensus) 과정이 필요하지 않다.

  그룹 복제는 다음과 같은 자동화된 기능을 제공한다.
    - 그룹 멤버 관리
    - 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지
    - 자동 페일오버
    - 자동 분산 복구
 */


### 17.2.1 - 그룹 복제 아키텍처
/**
  그룹 복제는 별도 플러그인으로 구현돼 있으며, 사용하기 위해서는 MySQL 서버에서 그룹 복제 플러그인이 설치돼 있어야 한다.

  그룹 복제에 참여하는 MySQL 서버들은 그룹 복제 플러그인을 통해 서로 간에 지속적으로 통신하며 복제 동기화를 처리한다.
  그룹 복제 플러그인은 그룹 복제가 설정되면 group_replication_applier라는 복제 채널을 생성하며,
  이 채널을 통해 그룹에서 실행된 모든 트랜잭션을 전달받아 적용하게 된다.

  또한, 이미 그룹에 참여하고 있는 다른 MySQL 서버들과 같이 그룹의 최신 데이터를 가지도록 하는 그룹 복제 분산 복구 작업이 필요한 경우
  복제 플러그인은 추가로 group_replication_recovery라는 복제 채널을 생성해서 분산 복구 작업을 진행한다.

  복제 플러그인의 내부 구조는 다음과 같다.
               MySQL SERVER
     ------------------------------- (이 아래부터 그룹 복제 플러그인이다.)
                Plugin API
            Replication Plugin
       Group Communication System API
         Group Communication Engine
                  (XCom)
     ------------------------------- (위에 있는 복제 플러그인에서 아래 그룹과 통신한다.)
                  Group

  Plugin API - 계층
  플러그인의 최상위 계층이고, 그룹 복제 플러그인과 MySQL 서버와의 상호작용하기 위해 플러그인 API 집합이 존재한다.
    - API를 통해 MySQL 서버에서 그룹 복제 플러그인으로 혹은 그 반대 방향으로 요청이 전달되며,
     MySQL 서버에서는 서버의 시작 또는 복구, 트랜잭션 커밋 등의 이벤트를 플러그인에 전달하고
     플러그인에서는 처리 중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 등을 서버에 전달한다.

  Replication Plugin - 계층
  그룹 복제의 기능이 실질적으로 구현돼 있는 계층이다.
    - 이 계층 내부는 여러 가지 모듈들로 나눠져 있으며, API를 통해 들어온 요청들은 각각 적절한 모듈로 전달한다.
    - 로컬 및 그룹 복제의 다른 MySQL 서버에서 실행된 원격 트랜잭션들이 처리되며, 트랜잭션들에 대한 충돌 감지 및 그룹 내 전파가 수행된다.
    - 또한, 분산 복구 작업도 이 계층에서 처리된다.

  Group Communication system API. Engie(XCom) - 계층
  상위 플러그인 계층에서는 '그룹 통신 시스템 API를 통해' 그룹 통신 엔진과 상호작용한다.
  그룹 통신 엔진은 'eXtended COMmunication' 또는 'XCOM'이라고 한다.
    - 다른 MySQL 서버들과의 통신 처리를 담당하는 복제의 핵심 구성 요소다.
    - 그룹 통신 엔진은 그룹 복제를 설정할 때 지정된 별도의 포트(일반적으로 33061)를 통해 수행한다.
    - 트랜잭션이 그룹 복제 멤버들에 동일한 순서로 전달될 수 있도록 보장해주며, 그룹 복제 토폴로지의 변경과 그룹 멤버의 장애 등을 감지한다.
     또한, 트랜잭션 적용 등을 위한 그룹 멤버 간의 합의 처리도 담당한다. (합의 처리를 위한 대표적인 알고리즘으로 Paxos, Raft가 있다)
        - Paxos : 분산 시스템에서 데이터 변경이 발생하는 서버가 여러 대 존재하는 경우 사용
        - Raft : 데이터 변경이 한 대에서만 발생하는 경우에 사용
    - 그룹 복제에서는 그룹 멤버들이 모두 쓰기를 처리할 수 있으므로 Paxos 계열의 Mencius 알고리즘을 기반으로 구현되어 있다.

  그룹 복제에서 또 다른 중요한 부분은 그룹 복제를 구성하는 MySQL 서버의 수다.
  이유는 그룹 복제에서 복제를 처리할 때 정상적으로 동작하려면 그룹의 과반수에 해당하는 서버가 정상적으로 동작하고 있어야 한다.
  하나의 서버가 장애가 발생하더라도 문제없이 처리되려면 적어도 세 대의 서버가 그룹에 존재해야 한다.
  따라서, 사용자는 허용 가능한 장애 서버 수(f)에 따른 전체 서버 수(n)을 다음과 같이 계산해서 서버 수를 결정해야 한다.
    n = 2f + 1 (n: 전체 서버수, f: 허용 가능한 장애 서버 수)
 */

### 17.2.2 - 그룹 복제 모드
/**
  쓰기를 처리할 수 있는 프라이머리 서버 수에 따라 싱글 프라이머리 모드와 멀티 프라이머리 모드 두 가지 동작 모드가 있으며,
  group_replication_single_primary_mode 시스템 변수를 통해 그룹 복제를 어떤 모드로 동작하게 할 것인지 설정할 수 있다.
        - MySQL 내장 시스템 변수가 아니라 플러그인을 설치해야 나오는 변수인거 같음
        SELECT @@group_replication_single_primary_mode; -- 플러그인이 없어서 그런지 Unknown system variable 에러
  group_replication_single_primary_mode 변수는 불리언 변수로 ON 이면 싱글, OFF 면 멀티 프라이머리도 동작한다. 기본값은 ON

  그룹 복제가 구축되고 복제에 참여하는 MySQL 서버들은 위 변수가 반드시 그룹 복제와 동일한 모드로 설정돼 있어야 한다.
  이 모드는 복제가 동작 중인 상황에서도 변경할 수 있는데, 이는 그룹 멤버들이 모두 8.0.13 이상의 버전을 사용할 때 가능하다.
  미만의 버전에서 모드를 변경하려면 그룹 복제를 중단한 후 모든 멤버들에서 위 변수의 값을 변경해야 된다.
  8.0.13 버전부터는 UDF를 사용해 현재 동작 중인 그룹 복제를 중단하지 않고 그룹 모드를 변경할 수 있다.
    - group_replication_switch_to_single_primary_mode() : 그룹 복제의 모드를 싱글 프라이머드로 변경
    - group_replication_switch_to_multi_primary_mode() : 그룹 복제의 모드를 멀티 프라이머드로 변경
 */

#### 17.2.2.1 - 싱글 프라이머리 모드
/**
  싱글 프라이머리 모드 : 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태
  싱글 모드에서 처음 구축할 때 그룹 복제 구축을 진행한 MySQL 서버가 프라이머리로 지정된다.
  프라이머리 서버가 아닌 다른 서버들은 그룹에 참여하는 시점에 자동으로 super_read_only 변수가 ON으로 된다.

  싱글 모드로 동작 중인 그룹에서 다음과 같은 상황이 벌어지면 그룹 내 프라이머리 서버가 변경될 수 있다.
    - 자발적으로 혹은 예기치않게 현재 프라이머리 서버가 그룹을 탈퇴하는 경우
    - group_replication_set_as_primary() UDF를 사용해 그룹의 '특정 멤버를 새로운 프라이머리로 지정'한 경우 (8.0.13 이상의 버전을 사용할 경우 해당)

  (탈퇴할 경우)
  현재 그룹의 프라이머리를 특정 멤버로 지정(위의 group_..._primary)하지 않을 경우에는 다음의 기준을 바탕으로 새로운 프라이머리를 선출하게 된다.
    1. MySQL 서버 버전
        새로운 프라이머리를 선출할 때 제일 우선으로 고려되는 요소로, 그룹 내에서 가장 낮은 MySQL 버전을 실행 중인 멤버를 확인한다.
        이를 위해 그룹 내에서 사용 중인 MySQL 버전을 정렬하게 되는데, 그룹 멤버들의 MySQL 버전에 따라 정렬 기준이 조금 다르다.
        모든 멤버가 8.0.17 이상의 버전을 사용 중인 경우 패치 버전을 기준으로 정렬된다.
        8.0.17 미만의 버전(5.7 포함)을 사용하고 있는 메버가 존재하는 경우 메이저 버전을 기준으로 정렬되며, 패치 버전은 무시한다.

    2. 각 멤버의 가중치 값
        가장 낮은 버전을 실행 중인 멤버가 둘 이상 존재하는 경우 group_replication_member_weight 변수에 지정된 가충치 값을 비교한다.
        group_..._weight 변수는 5.7.20 버전부터 도입됐으므로 미만의 버전으로 실행 중인 경우 이 기준은 무시된다.
        해당 변수에는 0 ~ 100 사이의 값을 지정할 수 있으며 기본값은 50이다.

    3. UUID 값의 사전식 순서
        서버 버전과 가중치를 기준으로 선정된 멤버가 둘 이상 존재하는 경우
        해당 멤버들이 가지는 UUID(server_uuid 변수의 값) 값의 사전식 순서를 바탕으로 가장 낮은 값을 가지는 멤버가 새로운 프라이머리로 최종 선택된다.
        SELECT @@server_uuid;

  현재 싱글 프라이머리 모드로 동작 중인 그룹 복제에서 어떤 서버가 프라이머리인지는 다음과 같인 확인할 수 있다.
  performance_schema의 replication_group_members 테이블에서 MEMBER_FOLE 컬럼값을 통해 확인할 수 있다.
 */
SELECT MEMBER_HOST, MEMBER_ROLE FROM performance_schema.replication_group_members;

#### 17.2.2.2 - 멀티 프라이머리 모드
/**
  그룹 멤버들이 전부 프라이머리로 동작하는 형태이고, 클라이언트는 그룹의 어떤 MySQL 서버로든 쓰기와 읽기 요청을 보낼 수 있다.
  이와 같이 쓰기가 그룹의 다른 멤버들에게 전파되어 각 멤버에서 다시 처리되므로 무엇보다도 그룹 멤버 간의 MySQL 버전 호환성이 중요하다.
    - 최적의 호환성과 성능을 신경쓰러면 모든 멤버가 동일한 MySQL 버전을 사용하는 것이 좋다.

  만약, 버전이 다를 경우 그룹 내에서 다른 멤버들과 호환되지 않을 가능성이 있다. (A에선 기능을 지원하고, B에선 지원하지 않을 경우)
  이를 방지하기 위해 그룹 복제에서는 서로 다른 버전을 사용 중인 그룹 멤버들 간에 버전 호환성을 확인하는 기능이 구현돼 있다.

  그룹 복제에 새로 참여하는 멤버는 그룹에 참여할 때 기존 멤버들과 버전 호환성 검사를 수행하며,
  그룹 복제에서 정의한 호환 가능 기준에 따라 그룹 참여 가능 여부와 읽기 전용 모드 유지 여부를 결정하게 된다.
  버전에 따른 호환 가능 기준은 다음과 같다.
    - 새로운 멤버가 그룹에 존재하는 가장 낮은 MySQL 버전보다 낮은 버전을 사용 중인 경우 그룹에 참여할 수 없다.
    - 새로운 멤버가 그룹에 존재하는 가장 낮은 MySQL 버전과 동일한 버전을 사용하면 참여할 수 있다.
    - 멀티 프라이머리 모드의 그룹에서는 새로운 멤버가 그룹에 존재하는 가장 낮은 MySQL 버전보다 높은 버전을 사용할 경우
     그룹에 참여할 수는 있지만, 읽기 전용 모드를 유지하게 된다.
    - 싱글 프라이머리 모드로 설정된 그룹에서는 버전에 상관없이 새로 참여하는 멤버는 항상 읽기 전용 모드로 설정된다.

  ****** 주의 ******
  기존 그룹 멤버들과 버전을 비교할 때는 사용 중인 MySQL 버전에 따라 비교 범위가 달라진다.
  새로운 멤버가 8.0.17 이상의 버전을 사용 중인 경우 기존 그룹 멤버들의 패치 버전까지 고려하며,
  8.0.17 미만의 버전(5.7 포함)을 사용 중인 경우엔 기존 그룹 멤버들의 메이저 버전을 비교하게 된다.

  서로 다른 버전을 사용하는 멀티 프라이머리 모드의 그룹 복제에서는 새로 참여하는 멤버가 읽기 전용 모드로 유지될 수 있다.
  또한, 8.0.17 이상의 버전을 사용하는 멤버들은 호환 가능 여부에 따라 그룹 복제에서 읽기 전용 및 읽기-쓰기 모드 전환을 자동으로 처리한다.

  - 멀티 프라이머리 모드에서 탈퇴할 경우
      어떤 멤버가 그룹에서 탈퇴할 경우 이를 감지해서 현재 그룹 내에서 가장 낮은 MySQL 버전을 사용하는 멤버를 다시 확인한 후,
      해당 멤버를 자동으로 읽기-쓰기 모드로 전환시킨다.
  - 만약, 싱글 프라이머리 모드에서 탈퇴한 다음 멀티 프라이머리 모드로 전환되는 경우
      group_replication_switch_to_multi_primary_mode() UDF를 통해 멀티 프라이머리 모드로 전환될 때
      그룹 내 멤버들의 MySQL 버전을 바탕으로 각 멤버들을 자동으로 적절한 모드로 설정한다.
      그룹에서 사용 중인 가장 낮은 MySQL 버전보다 높은 버전을 사용 중인 멤버들은 읽기 전용 모드로 설정하고,
      가장 낮은 버전을 사용하는 멤버들은 읽기-쓰기 모드로 설정한다.
 */

### 17.2.3 - 그룹 멤버 관리 (Group Membership)
/**
  그룹 복제에서는 그룹 멤버들에 대한 목록과 상태 정보를 내부적으로 관리하고 있다.
  performance_schema의 replication_group_members 테이블 통해 그룹 멤버 목록을 확인할 수 있다.
  멤버가 새로 가입하거나 혹은 탈퇴하면 그룹 복제에서는 이를 감지해서 해당 테이블 데이터를 자동으로 갱신한다.
    GR_mysql > SELECT * FROM performance_schema.replication_group_members \G

  replication_group_members 데이터를 통해 그룹 멤버들의 호스트명과 사용하는 포트, UUID 값, MySQL 버전을 확인할 수 있고,
  그룹 멤버들의 역할도 알 수 있다. 또한, MEMBER_STATE 컬럼을 통해 멤버의 현재 상태도 확인할 수 있다.
  MEMBER_STATE 컬럼에는 다음과 같은 값이 표시될 수 있다.
    - ONLINE
        그룹 복제의 한 구성원으로서 정상적으로 동작하고 있음
    - RECOVERING
        그룹 복제에 참여하기 위해 기존 그룹 멤버로부터 데이터를 전달받는 복구 작업이 진행되고 있음
    - OFFLINE
        그룹 복제 플러그인이 로딩돼 있으나 아직 그룹 복제에 참여하지 않은 상태
    - ERROR
        그룹 복제에 속해 있으나 정상적으로 복제가 동작하고 있지 않는 상태
        복제 동기화에 오류가 발생하는 등의 문제로 이 같은 상태가 표시될 수 있으며,
        그 외에도 다양한 문제들로 인해 그룹 멤버의 상태값이 ERROR 값으로 표시될 수 있다.
    - UNREACHABLE
        현재 통신이 불가능하다고 판단되는 멤버에 대해 표시하는 상태 값

  그룹 복제가 관리하는 멤버 목록과 상태 정보를 '뷰(View)'라고도 하는데,
  그룹 복제에서 멤버는 새로 가입하거나 탈퇴할 수 있으므로 뷰는 특정 시점의 그룹 멤버 목록이라고 할 수 있다.
  뷰는 뷰 ID라는 고유 식별자를 가지며, 그룹 멤버가 변경될 때마다 새로운 뷰 ID 값이 생성된다.
  따라서, 뷰 ID는 변경된 뷰를 고유하게 식별하는 것이며, 이를 통해 뷰의 변경을 추적하고 뷰가 변경된 시점을 구분할 수 있다.

  뷰 ID는 다음과 같이 두 부분으로 구성되어 있다.
  View ID = [Prefix value] : [Sequence value]

  Prefix value : 그룹 복제가 초기화될 때 생성되며, 그 시점의 타임스탬프를 기반으로 값이 만들어진다.
    이 부분은 생성된 그룹이 유지되는 동안, 즉 그룹에 적어도 하나의 멤버가 존재하는 동안은 값이 변경되지 않는다.
    이를 통해 두 뷰에 대해 동일한 그룹의 다른 시점인지 아니면 아예 다른 그룹의 뷰인지를 구분할 수 있다.

  Sequence value : 단조 증가하는 정숫값으로, 값은 1부터 시작하며 그룹에서 멤버가 변경될 때마다 1씩 증가한다.

  그룹의 현재 뷰 ID 값은 performance_schema의 repliaction_group_member_stats 테이블에서 VIEW_ID 컬럼을 통해 확인할 수 있다.
  GR_mysql > SELECT VIEW_ID FROM performance_schema.replication_group_member_stats LIMIT 1;

  뷰 ID 값이 변경되면 바이너리 로그에도 'View_change'라는 이벤트로 뷰 변경 내역이 기록된다.
  그러나, 그룹에 새로운 멤버가 추가되어 뷰가 변경되는 경우에만 기록된다.
  -- 뷰 변경 내역이 기록된 바이너리 로그를 보는 예
  GR_mysql > SHOW BINARY EVENTS IN 'mysql-bin.000004' FROM POS_값 LIMIT 1;
 */

### 17.2.4 - 그룹 복제에서의 트랜잭션 처리
/**
  그룹 복제에서 트랜잭션은 다음의 단계들을 거친 후 최종적으로 그룹의 각 서버들에게 적용된다
  - 합의(Consensus)
  - 인증(Certification)

  합의(Consensus)는 그룹 내 일관된 트랜잭션 적용을 위해 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙받는 과정이다.
  따라서, 그룹 멤버 간의 통신 결과를 바탕으로 처리된다.
  합의의 과정은 다음과 같다.
  1. 클라이언트가 한 그룹 멤버에서 트랜잭션을 실행하고 커밋 요청을 보낸다.
  2. 해당 그룹 멤버는 그룹 통신 엔진(XCom)을 통해 트랜잭션에서 변경한 데이터에 대한 WriteSet과
    트랜잭션이 커밋될 당시의 gtid_executed 스냅샷 정보와 트랜잭션의 이벤트 로그 데이터 등이 포함된 트랜잭션 데이터를 그룹의 다른 멤버들로 전파한다.
    전파 대상 멤버들은 현재 그룹 내에서 정상적인 상태로 동작 중인 멤버들이다.
  3. 그룹 통신 엔진에서는 트랜잭션 데이터를 전파하면서 Paxos 기반의 프로토콜을 바탕으로 그룹 멤버들 간의 합의를 수행한다.
  4. 최종적으로 합의가 완료되어 트랜잭션이 실해된 멤버에서 그룹의 과반수 이상에 해당하는 멤버로부터 응답 메시지(ACK)를 전달 받으면
    해당 멤버는 다음 프로세스를 진행하게 된다.
    만약, 과반수 이상의 멤버들로부터 응답을 받지 못한 경우 그룹 복제에서 트랜잭션은 적용되지 않으며 클라이언트에 에러가 반환된다.

  다수의 그룹 멤버들에서 실행된 트랜잭션들은 합의 단계를 거친 후 글로벌하게 정렬되어, 각 멤버들에서 모두 동일한 순서로 인증 단계를 거치게 된다.
  인증 단계에서 각 멤버들은 전달받은 트랜잭션 WriteSet 데이터와 로컬에서 내부적으로 관리하고 있는 WriteSet 히스토리 데이터를 바탕으로
  해당 트랜잭션이 이미 인증 단계를 거친 선행 트랜잭션과 동시점에 동일한 데이터를 변경한 것인지를 검사해서 트랜잭션 충돌 여부를 확인한다.
  이러한 트랜잭션 충돌은 그룹 멤버 전체가 쓰기를 처리할 수 있는 멀티 프라이머리 모드에서만 발생할 수 있으며,
  단일 서버에서 쓰기가 수행되는 싱글 프라이머리 모드에서는 발생하지 않는다.

  인증 단계에서 트랜잭션 충돌이 감지된 트랜잭션은 커밋되지 못하고 롤백된다.
  따라서, 트랜잭션 충돌이 자주 발생할 수 있는 환경에서는 싱글 프라이머리 모드로 사용해 자동으로 롤백되지 않고 대기 후 처리될 수 있게 하는 것이 더 좋다.

  각 트랜잭션이 실행된 로컬 멤버에서는 인증 단계를 거친 후 바이너리 로그에 트랜잭션을 기록하고 최종적으로 커밋을 완료하며,
  클라이언트는 이 시점에 커밋 요청에 대한 응답을 받게 된다.
  원격으로 트랜잭션 데이터를 전달받은 그룹의 다른 멤버들은 인증 단계를 수행한 후 함께 전달받은 트랜잭션 로그 데이터를 바탕으로 릴레이 로그 인벤트를 작성한다.
  그리고, 그룹 복제의 어플라이어 스레드에서는 릴레이 로그에 기록된 트랜잭션을 실행하고 바이너리 로그에도 기록해서
  최종적으로 서버에 해당 트랜잭션을 적용하게 된다.

  Real MySQL 2권 573p 그림을 보면 좀 더 쉽게 이해 가능
 */

#### 17.2.4.1 - 트랜잭션 일관성 수준
/**
  그룹 복제에서 각 멤버들은 동일한 트랜잭션을 적용하지만 실제 적용 시점까지 일치하는 것은 아니다. 이로 인해 다음과 같은 문제가 발생한다.
    - 한 멤버에서 쓰기를 수행한 후 바로 다른 멤버에서 해당 데이터를 읽었을 때 최신 변경 사항이 아닐 수 있다.
    - 프라이머리 장애로 인해 페일오버가 발생하는 경우에도 위와 같은 상황 발생
        새로 선출된 프라이머리가 아직 이전 프라이머리에서 발생했던 트랜잭션들을 적용하고 있는 상황에서
        클라이언트가 새로운 프라이머리로 연결해서 트랜잭션을 실행하는 경우 오래된 데이터를 읽거나 쓸 수 있게 된다.
  일반적으로 그룹 복제가 정상적으로 동작하고 있다면 이러한 상황은 잘 일어나지 않지만 아주 짧은 순간에 발생할 수 있어서
  이러한 상황에 민감한 서비스에서는 문제가 될 가능성이 있다.

  위 상황의 문제들을 8.0.14 버전 이전까지는 방지할 방법이 없지만 이후 버전에선 트랜잭션의 일관성 수준을 설정할 수 있는 기능이 생겨
  사용자가 필요에 따라 원하는 수준의 일관성을 선택해서 사용할 수 있다.
  group_replication_consistency 시스템 변수를 통해 그룹 복제에서의 트랜잭션 일관성 수준을 설정할 수 있으며,
  적용 범위는 글로벌 또는 세션 모두 가능하다. 설정된 일관성 수준은 읽기 전용과 쓰기 트랜잭션에 다른 영향을 미친다.
    - 경우에 따라 다른 멤버에서 실행 중인 트랜잭션에도 영향을 줄 수 있다

 */

-- groupt_replication_consistency 시스템 변수에 설정 가능한 일관성 수준에 대해 살펴보자.
##### 17.2.4.1.1 - EVENTUAL 일관성 수준
/**
  EVENTUAL 일관성 수준은 group_replication_consistency 변수의 기본 값으로,
  해당 변수가 추가되기 전, 그룹 복제에서의 트랜잭션 일관성 수준과 동일하다.
  즉, 이름 그대로 최종적으로는 그룹 멤버들이 일관된 데이터를 가지게 됨을 의미한다.

  EVENTUAL 일관성 수준에서는 읽기 전용 및 읽기-쓰기 트랜잭션이 별도의 제약 없이 바로 실행 가능하다.
  즉, 위에서 보았던 문제점들을 그대로 안고 있다.
    - 한 멤버에서 쓰기를 수행한 후 다른 멤버에서 읽기를 했을 때 최신 변경 사항이 아닌 문제, 프라이머리 페일오버 발생으로 인한 문제

  또한, 신규 프라이머리에서 이전 프라이머리의 변경 내역들을 반영하다 충돌이 발생할 경우 롤백된다.
 */
select @@group_replication_consistency;

##### 17.2.4.1.2 - BEFORE_ON_PRIMARY_FAILOVER 일관성 수준
/**
  BEFORE_ON_PRIMARY_FAILOVER 일관성 수준은 싱글 프라이머리 모드로 설정된 그룹 복제에서
  프라이머리 페일오버가 발생해 신규 프라이머리가 선출됐을 때만 트랜잭션에 영향을 미친다.

  새로 선출된 프라이머리가 BEFORE_ON_PRIMARY_FAILOVER 일관성 수준으로 설정돼 있고 아직 이전 프라이머리의 트랜잭션을 적용하고 있는 경우
  새로운 프라이머리로 유입된 트랜잭션은 이전 프라이머리의 트랜잭션이 모두 적용될 때까지 처리되지 못하고 대기하게 된다.

  페일오버 시점에 신규 프라이머리로 유입된 트랜잭션들의 대기 시간은 신규 프라이머리와 이전 프라이머리 간의 트랜잭션 갭에 따라 달라진다.
  페일오버가 발생하기 직전까지 그룹 멤버들 간에 복제 동기화가 잘 처리되고 있던 상황이라면 트랜잭션 갭은 아주 적은데,
  갭이 큰 경우 트랜잭션들의 대기 시간이 길어져 클라이언트에서 응답 지연을 겪을 수 있다.
  따라서, 이 같은 지연을 대비하는 코드가 구현돼 있는 것이 좋다. (어떻게..?)
  또한, 대기 시간이 wait_timeout 변수에 설정된 값을 초과하면 ER_GR_HOLD_WAID_TIMEOUT 에러가 반환된다. (기본값은 8시간)
SELECT @@wait_timeout; -- 28800

  BEFORE_ON_PRIMARY_FAILOVER 일관성 수준에는 다음과 같은 부분들이 보장된다.
    - 신규 프라이머리로 유입된 읽기 전용 및 읽기-쓰기 트랜잭션들은 최신 데이터를 바탕으로 동작한다.
    - 신규 프라이머리로 유입된 읽기-쓰기 트랜잭션은 적용 대기 중인 이전 프라이머리의 트랜잭션과의 충돌로인해 롤백될 수 있는데,
     BEFORE_ON_PRIMARY_FAILOVER 일관성 수준을 사용하면 롤백은 발생하지 않게 된다.

  위에서 봤듯이 BEFORE_ON_PRIMARY_FAILOVER 일관성 수준에서 트랜잭션 갭으로 인해 지연이 발생하는데,
  모든 종류의 트랜잭션이 지연이 생기는 것은 아니다. 읽기 전용 트랜잭션 중에서 MySQL 서버 모니터링 등을 위한 일부 쿼리들은 바로 실행 가능다.
  서버 모니터링을 위해 바로 실행 가능한 쿼리는 다음과 같다.
    - SHOW 문
    - SET 문
    - DO 문
    - EMPTY 문
    - USE 문
    - performance_schema 및 sys 데이터베이스에 대한 SELECT 문
    - information_schema.PROCESSLIST 테이블에 대한 SELECT 문
    - 테이블 또는 사용자 정의 함수를 사용하지 않는 SELECT 문
    - STOP GROUP_REPLICATION 문
    - SHUTDOWN 문
    - RESET PERSIST 문

  해당 일관성 수준은 프라이머리 페일오버가 발생하지 않는 상황에서는 프라이머리로 유입된 트랜잭션들에 아무런 영향을 미치지 않는다.
  즉, 일반적인 상황에서는 트랜잭션들이 EVENTUAL 일관성 수준으로 설정된 트랜잭션 처럼 처리된다고 할 수 있다.
 */

##### 17.2.4.1.3 - BEFORE 일관성 수준
/**
  BEFOR 일관성 수준에서 읽기 전용 및 읽기-쓰기 트랜잭션 모두 선행 트랜잭션이 완료될 때까지 대기 후 처리된다.
  선행 트랜잭션이란 해당 트랜잭션이 실행된 그룹 멤버에서의 선행 트랜잭션만을 의미한다. (전체 그룹 x)

  BEFORE_ON_PRIMARY_FAILOVER와 같이 항상 최신 데이터를 읽으며, 트랜잭션 처리 시간은 선행 트랜잭션의 처리 시간에 영향을 받는다.
  위에서 본 wait_timeout 변수에 설정된 시간까지 대기할 수 있으며 이를 초과하면 에러가 발생한다.

  이와 같은 성격들로 인해 읽기 요청은 적고 쓰기 요청이 많은 경우에 사용하는 것이 좋다.

  BEFORE_ON_PRIMARY_FAILOVER 일관성 수준과 동일한 일관성 보장을 제공한다.
 */

##### 17.2.4.1.4 - AFTER 일관성 수준
/**
  트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 한다.
  즉, 읽기-쓰기 트랜잭션은
  다른 모든 멤버들에서도 해당 트랜잭션이 커밋될 준비가 됐을 때까지 대기한 후 다른 멤버들로부터 응답을 받으면 최종적으로 처리되며,
  읽기 전용 트랜잭션은 데이터 변경을 발생시키지 않으므로 별도의 제약 없이 바로 처리된다.

  해당 일관성 수준은 다른 멤버에서 동시점에 실행되는 트랜잭션에 영향을 미친다.
  만약, AFTER 일관성 수준으로 설정된 트랜잭션이 실행되는 동안 다른 멤버에서 새로운 트랜잭션이 실행되면
  해당 트랜잭션은 AFTER 일관성 수준의 트랜잭션이 완전히 커밋될 때까지 대기하게 된다.
  따라서, AFTER 일관성 수준은 그룹에서 정상적으로 동작 중인 모든 멤버에 영향을 미친다고 할 수 있다.

  그룹의 어떤 멤버에서든 일관된 최신 데이터를 얻을 수 있다. (모든 멤버들이 커밋 준비가 되어야지 트랜잭션이 적용되므로)

  읽기-쓰기 트랜잭션은 다른 멤버들에서 트랜잭션 커밋이 분비될 때까지 대기하므로 본래의 처리 시간보다 더 많은 시간을 소요하게 된다.
  따라서, AFTER 일관성 수준은 쓰기 요청보다 읽기 요청이 많고, 분산된 최신 읽기를 수행하고자 할 때 사용하는 것이 좋다.

  BEFORE_ON_PRIMARY_FAILOVER 일관성 수준과 동일한 일관성 보장을 제공한다.
  위에서 봤듯이 watie_timeout 대기 시간이 초과하면 에러 발생한다.
 */

##### 16.2.4.1.5 - BEFORE_AND_AFTER 일관성 수준
/**
  BEFORE 수준과 AFTER 수준이 결합된 형태이다.
  읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 기다린 후 실행되며,
    트랜잭션이 다른 모든 멤버들에서도 커밋이 준비되어 응답을 보내면 그때 최종적으로 커밋한다.
  읽기 전용 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 대기한 후 실행된다.

  BEFORE_AND_AFTER 일관성 수준으로 설정된 트랜잭션에서는 최신 데이터를 읽을 수 있으며,
  읽기-쓰기 트랜잭션의 경우 커밋되면 이후 모든 후속 트랜잭션들은 어떤 멤버에서든지 해당 트랜잭션의 변경 사항을 포함하는 최신 데이터를 읽게 된다.

  해당 트랜잭션의 일관성 수준은 AFTER와 동일하게 다른 멤버들에서 실행되는 트랜잭션들에 영향을 미친다.
  BEFORE_ON_PRIMARY_FAILOVER 일관성 수준과 동일한 일관성 보장을 제공한다.
  관련한 트랜잭션 대기 시간도 다른 일관성 수준과 같다. (wait_timeout 기반)
 */

#### 17.2.4.2 - 흐름 제어 (Flow Control)
/**
  그룹 복제에서 일부 멤버가 다른 멤버들보다 하드웨어 스펙이 낮거나, 네트워크 대역폭이 작거나, 부하를 더 많이 받고 있는 경우
  해당 멤버는 다른 멤버들보다 트랜잭션 적용이 지연될 수 있다.

  이렇게 지연된 멤버에서 트랜잭션이 실행되면
  해당 트랜잭션은 최신 데이터가 아닌 오래된 데이터를 읽을 수 있으며, 아직 적용되지 않은 트랜잭션과 충돌할 위험이 있다.
    - 트랜잭션 일관성 수준을 이용해 방지할 수 있지만,
     근본적인 원인이 해결되는 것이 아니므로 지연이 장시간 지속될 경우 이마저도 해결책이 될 수 없다.

  이처럼 그룹 멤버 간의 트랜잭션 적용 불균형으로 발생하는 문제를 방지하기 위해
  그룹 멤버들의 쓰기 처리량을 조절하하는 매커니즘이 구현돼 있으며, 이를 흐름 제어(Flow Control)라고 한다.

  흐름 제어를 통해 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들의 데이터가 최대한 동기화된 상태로 유지될 수 있게 하며,
  그룹에 평소와 다른 워크로드가 유입되는 등의 변화에도 멤버들의 쓰기 처리량이 균등하게 할 수 있게 한다.
  또한, 필요 이상으로 처리량을 줄이지 않음으로써 서버의 자원이 불필요하게 유휴 상태에 놓여 있지 않게 한다.

  group_replication_flow_control_mode 변수를 통해 멤버에서 흐름 제어 기능의 사용 여부를 설정할 수 있다.
  해당 변수는 흐름 제어를 어떤 모드로 사용할지 설정하는 변수인데, 현재 아직 QUOTA 모드밖에 존재하지 않으며,
  QUOTA 또는 DISABLED 값으로 설정할 수 있다.
        23.08.25 기준으로 아직 위에 두 값 밖에 없다
        https://dev.mysql.com/doc/refman/8.0/en/group-replication-system-variables.html#sysvar_group_replication_flow_control_mode

  QUOTA 모드는 해당 변수의 기본값이다.
  흐름 제어의 기본 모드로 그룹에서 쓰기를 처리하는 멤버가 정해진 할당량만큼만 쓰기를 처리하도록 제어하는 방식이다.

  DISABLED로 설정되는 경우 흐름 제어는 동작하지 않는다.
  흐름 제어가 비활성화 되어 잇는 멤버의 경우 현재 트랜잭션을 적용하지 않고 있거나
  혹은 아직 적용하지 못한 트랜잭션이 많이 가지고 있더라도, 다른 멤버들의 흐름 제어에 영향을 주지 않는다.
  즉, 이 멤버로 인해 다른 멤버들의 쓰기 처리량이 조정되지 않는다.

  QUOTA 모드로 설정된 흐름 제어의 동작 방식은 다음과 같다.
    1. 모든 그룹 멤버들의 쓰기 처리량 및 처리 대기 중인 트랜잭션에 대한 통계를 수집해서 멤버의 처리량을 조절할 필요가 있는지 확인
    2. 처리량 조절이 필요한 경우 수집된 통계 데이터를 바탕으로 멤버에게 할당할 쓰기 처리량을 계산한 뒤,
       멤버가 계산된 최대 쓰기 처리량이 넘어 쓰기를 처리하지 않도록 멤버의 쓰기 처리를 제한한다.

  흐름 제어는 각 멤버에서 개별적으로 수행된다. (그룹 전반에 걸쳐 동기화된 형태로 수행되지 않는다.)

  흐름 제어에서는 멤버에서 다음과 같은 통계 정보들을 수집하며, 수집된 데이터들은 다른 멤버들에게도 공유된다.
    - 인증(Certification) 큐 크기
    - 적용(Application) 큐 크기
    - 인증된 총 트랜잭션 수
    - 적용된 원격 트랜잭션 수
    - 로컬 트랜잭션 수

  통계 정보 데이터는 group_replication_flow_control_period 변수에 지정된 시간(초 단위)마다 수집 및 공유된다.
  기본적으로 매 초다마다 동작하며, 멤버 로컬에서 수집한 통계 정보와 다른 멤버들로부터 전달받은 통계 정보를 바탕으로 쓰기 처리량을 계산한다.
    ************    주의  **************
    * 각 멤버에서 다른 멤버에 대한 통계 정보는 적어도 10 주기에 한 번씩 업데이트 되지 않으면 삭제되기 때문에
    * 10배 더 큰 값으로 설정하는 경우는 주의해야 한다. (일부 주기가 무시될 수 있음)
    ************************************

  흐름 제어에서는 로컬 멤버를 포함해서 그룹의 모든 멤버들에의 트랜잭션 처리 과정 중
  트랜잭션의 충돌을 감지하는 인증(Certification) 단계와 실제로 트랜잭션을 반영하는 적용(Application) 단계에서
  얼마나 많은 트랜잭션이 대기하고 있는지를 확인하는 것이다. (흐름 제어가 비활성화돼 있는 멤버의 통계 정보는 무시)
  다음 두 변수를 통해 각 단계별로 흐름 제어가 처리량 조절을 시작하는 임곗값을 설정할 수 있다.

    - group_replication_flow_control_certifier_threshold
        단위는 트랜잭션 수로, 인증 큐에서 대기 중인 트랜잭션 수가 해당 변수에 지정된 수를 초과하면 흐름 제어가 작동한다.
    - group_replication_flow_control_applier_threshold
        단위는 트랜잭션 수로, 어플라이어 큐에서 대기 중인 트랜잭션 수가 해당 변수에 지정된 수를 초과하면 흐름 제어가 작동한다.
    두 변수 모두 기본값은 25000이고, 0 ~ 2147483647 범위로 설정할 수 있다. (INF 범위?)

  흐름 제어에서 멤버의 쓰기 처리량을 조절할 필요가 있다고 판단되면,
  통계 정보를 바탕으로 트랜잭션 적용이 가장 뒤처진 멤버가 처리할 수 있는 수준으로 멤버의 쓰기 처리량을 계산한다.
  이렇게 계싼된 값은 멤버에 바로 적용되는 것은 아니며,
  흐름 제어에서 멤버에게 할당하는 쓰기 처리량과 관련된 변수들의 값을 참조해서 최종적으로 할당할 쓰기 처리량을 결정하게 된다.

  흐름 제어 제어에서 결정되는 쓰기 처리량과 관련한 시스템 변수 (사용자가 설정할 수 있음)
  공식문서에서 확인 가능 - https://dev.mysql.com/doc/refman/8.0/en/group-replication-system-variables.html
                      (cmd + f후 group_replication_flow_control_)
    - group_replication_flow_control_min_quota
        흐름 제어에서 계산된 쓰기 처리량과 관계없이 멤버에게 할당돼야 하는 최소 쓰기 처리량을 설정, 단위는 트랜잭션이다.
        기본값은 0이고, 0 ~ 2147483647 범위로 설정 가능 (0이면, 최소 쓰기 처리량 제한이 없음을 의미)
        이 값은 group_replication_flow_control_max_quota 변수의 값보다 크게 설정할 수 없음

    - group_replication_flow_control_min_recovery_quota
        그룹에서 복구 상태의 멤버가 존재하는 경우 위 변수 대신 적용되는 변수이다.
        값의 범위, 기본값 모두 동일 위와 마찬가지고 grout_..._max_quota 변수 값보다 크게 설정할 수 없다.

    - group_replication_flow_control_max_quota
        흐름 제어에서 그룹에 할당할 수 있는 최대 쓰기 처리량을 설정. (싱글 프라이머리 모드 그룹의 경우 프라이머리에 할당할 수 있는 최대 쓰기 처리량)
        값의 범위, 기본값 모두 위와 동일
        위 두 변수의 값보다 커야 된다.

    - group_replication_flow_control_member_quota_percent
        멤버에게 할당할 쓰기 처리량에서 실제로 얼마 정도의 양을 멤버가 사용하게 할 것인지 백분율 설정 (0 ~ 100, 기본값 0)
        그룹이 멀티 프라이머리 모드인 경우에만 유효

    - group_replication_flow_control_hold_percent
        멤버에게 할당되는 쓰기 처리량에서 사용하지 않고 남겨둘 처리량의 백분율 설정 (0 ~ 100, 기본값 10)

    - group_replication_flow_control_release_percent
        흐름 제어에서 더이상 쓰기 멈베에 대해 처리량을 제한할 필요가 없을 때 흐름 제어 주기당 증가시킬 할당량의 백분율 설정
        (0 ~ 100, 0으로 설정되면 다음 주기에서 흐름 제어에 의한 처리량 조절이 해제됨)

    위 변수들은 모두 동적으로 변경 가능하며, 그룹 복제를 중단하지 않더라도 변견된 값으로 즉시 반영된다.
 */
-- InnoDB 클러스터 복제 환경 구성이 되어야지 설정되는 변수인거 같음..
select @@group_replication_flow_control_mode;
show variables like '%group_replication%';

### 17.2.5 - 그룹 복제의 자동 장애 감지 및 대응
/**
  장애 감지 매커니즘은 문제 상태에 있는 멤버를 식별하고 해당 멤버를 그룹 복제에서 제외시켜 그룹이 정상적으로 동작하게 만든다.

  그룹 복제에서 멤버 간에 주기적으로 통신 메시지를 주고받으며 서로 상태를 확인하는데,
  멤버로부터 5초 내로 메시지를 받지 못하면 해당 멤버에 문제가 생긴 것으로 의심하기 시작한다.
  장애가 의심되는 멤버에 대해 과반수의 멤버가 동의하면 해당 멤버를 그룹에서 추방한다.

  8.0.20 버전까지는 의심되는 즉시 그룹에서 추방됐으나, 8.0.21 버전부터 5초의 대기 시간이 추가되었다.
  추방되기 전 대기 시간 동안 멤버는 UNREACHABLE 상태로 표시된다.
  대기 시간은 group_replication_member_expel_timeout 변수로 확인할 수 있으며 (기본값이 5초)
  8.0.14 버전부터 최대 1시간까지 설정 가능하다. (8.0.13 버전에선 1년까지 했었다고 한다)
    GR_mysql > SET GLOBAL group_replication_member_expel_timeout=N; (0 <= N <= 3600)

  group_replication_member_expel_timeout 변수를 기본값으로 사용하지 말고 (네트워크가 느릴 경우 대비)
  좀 더 큰 적절한 값으로 설정하는 것이 좋다. (네트워크 작업으로 일시적인 네트워크 통신이 중단될 경우 해당 변수의 값을 늘려놓자.)

  멤버가 추방되면 그룹 뷰가 변경되므로 그룹 멤버들은 새로운 뷰 ID 값을 갖게 된다.
  추방된 멤버가 장애가 복구돼 다시 그룹에 연결되면 그룹의 현재 뷰 ID가 자신이 자긴 뷰 ID와는 다르므로 그룹에서 추방됐음을 알게 된다.
  group_replication_autorejoin_tries 시스템 변수에 따라 자동으로 재가입을 시도할 수 있다. (8.0.16 버전에서 도입된 변수)
  위 변수에 설정된 값만큼 그룹에 재가입을 시도하게 된다. (각 시도당 5분의 간격으로 시도하고 최대 값은 2016, 기본값은 3이다)
    GR_mysql > SET GLOBAL group_replication_autorejoin_tries=N; (0 <= N <= 2016)

  멤버의 재가입 시도에 대한 정보는 performance_schema.events_stages_current 테이블을 통해 확인할 수 있다.
    -- 자동 재가입 프로세스 동작 여부 확인
    GR_mysql> SELECT COUNT(*)
              FROM performance_schema.events_stages_current
              WHERE event_name LIKE '%auto-rejoin%';

    -- 지금까지 재가입을 시도한 횟수
    GR_mysql> SELECT (WORK_COMPLETED - 1) AS rejoin_num
              FROM performance_schema.events_stages_current
              WHERE event_name LIKE '%auto-rejoin%';

    -- 다음 재가입까지 남은 시간
    GR_mysql> SELECT
                ROUND(360 - ((TIMER_WAIT * 10e - 13) - 360 * (WORK_COMPLETED - 1)), 2) AS remaining_seconds
              FROM performance_schema.events_stages_current
              WHERE event_name LIKE '%auto-rejoin%';

  소수에 속한 그룹에 대한 얘기가 나오는데 아직 이해가 잘 안돼 책을 보시면 좋을거 같습니다. (추후 이해가 됐을 때 추가로 적을 예정)

  멤버가 그룹의 다른 멤버들과의 통신 단절 등의 문제로 인해 타의 혹은 자의로 그룹에서 탈퇴한 상태에서
  자동 재가입에 실패하거나 재가입을 아예 시도하지 않게 설정된 경우
  멤버는 최종적으로 종료 액션이라는 명칭으로 group_replication_exit_state_action 변수에 설정된 작업을 진행한다. (8.0.12 버전부터 사용 가능)

  group_replication_exit_state_action 변수에 설정 가능한 값과 각 값으로 설정됐을 때 MySQL 서버에 조치되는 내용은 다음과 같다.
    - READ_ONLY
        super_read_only 변수를 ON으로 설정해서 MySQL 서버를 읽기 전용 모드로 전환시킨다.
        8.0.16 버전부터 group_replication_exit_state_action 변수의 기본값이 이 값으로 변경됐다.

    - OFFLINE_MODE (8.0.18 버전부터 사용 가능)
        offline_mode 변수를 ON으로 설정해서 MySQL 서버를 오프라인 모드로 전환시킨다.
        오프라인 모드에서는 기존에 이미 연결돼 있는 세션의 경우 다음 요청에서 연결이 끊어지고,
        CONNECTION_ADMIN 권한을 가진 사용자를 제외하고 더 이상 연결을 허용하지 않는다.

    - ABORT_SERVER
        MySQL 서버를 종료시킨다.

  group_replication_exit_state_action 변수에 설정된 작어비 동작하게 되는 구체적인 경우
    - 그룹 복제의 어플라이어 스레드에 에러가 발생한 경우

    - 멤버가 그룹 복제의 분산 복구 프로세스를 정상적으로 완료할 수 없는 경우

    - group_replication_switch_to_single_primary_mode() 같은 그룹 복제 UDF를 사용해
      그룹 전체에 대한 설정을 변경하는 중 에러가 발생한 경우

    - 싱글 프라이머리 모드의 그룹에서 새 프라이머리 선출 과정 중 에러가 발생한 경우

    - 과반수 이상의 다른 그룹 멤버들과 통신이 단절되고,
      group_..._majority_timeout 변수에 설정된 대기 시간치 초과됐으나 그룹에 재가입 시도를 하지 않은 경우

    - 멤버에 문제가 발생해서 group_..._expel_timeout 변수에 설정된 대기 시간이 초과된 후 그룹에서 추방되고,
      다시 그룹의 다른 멤버들과 통신이 재개되어 추방됐음을 확인했으나 그룹에 재가입 시도를 하지 않은 경우

    - 멤버가 자의 혹은 타의로 그룹에서 탈퇴한 후
      group_..._autorejoin_tries 변수에 지정된 횟수동안 재가입을 성공하지 못한 경우
 */

### 17.2.6 - 그룹 복제의 분산 복구
/**
  멤버가 그룹에 새로 가입하거나 혹은 탈퇴 후 다시 가입할 때, 그룹을 떠나있을 동안 그룹에 적용된 트랜잭션들이 있을 수 있다.
  이런 누락된 트랜잭션들을 다른 그룹 멤버에서 가져와 적용하는 복구 프로세스를 자동으로 수행하게 되는데 이를 '분산 복구'라고 한다.
    - 누락된 트랜잭션들을 모두 복구해야 다른 그룹 멤버들이 가진 데이터와 동일한 데이터를 갖게 된다.

  분산 복구에서 가입 멤버가 복구 작업을 위해 선택한 기존 그룹 멤버를 기증자(Donor) 멤버라고 하며,
  그룹에서 온라인 상태로 존재하는 모든 멤버들은 기증자 멤버가 될 수 있다.
 */

#### 17.2.6.1 - 분산 복구 방식
/**
  분산 복구에서는 복구 작업 시 먼저 가입 멤버에서 group_replication_applier 복제 채널의 릴레이 로그를 확인한다.
  미처 적용되지 못하고 남아 있는 트랜잭션이 있는지 확인하고 이를 먼저 적용하는 것으로 복구 작업을 시작한다. (그룹에 새로 가입하는 멤버는 해당 안됨)
    - 가입하려는 멤버가 이전에 그룹에 가입한 적이 있다면 그룹을 탈퇴하는 시점에 릴레이 로그와 비교

  가입한 멤버의 릴레이 로그를 확인한 이후엔 그룹에 온라인 상태로 존재하는 다른 그룹 멤버에 연결해서 분산 복구 작업을 진행한다.
  이때 분산 복구에는 다음과 같은 두 가지 방식을 조합해서 진행한다.
    1. 바이너리 로그 복제 방식
    2. 원격 클론(Remote Cloning) 방식

  바이너리 로그 복제 방식 :
    - MySQL의 기본 복제 방식인 비동기 복제를 기반으로 구현되어 있다.
    - 기증자로 선택된 다른 그룹 멤버와 별도의 복제 채널로 연결되어 해당 멤버의 바이너리 로그에서
      새로 가입한 멤버에 적용되지 않은 트랜잭션들을 복제해서 가져와 가입한 멤버에 적용하는 방식이다.
    - 별도의 복제 채널 이름은 group_replication_recovery 이다.

  원격 클론 방식 :
    - 8.0.17 버전에서 도입된 클론 플러그인(Clone Plugin)을 사용하는 형태이다.
    - 다른 그룹 멤버의 InnoDB 스토리지 엔진에 저장된 모든 데이터와 메타데이터를 일관된 스냅샷으로 가져와
      가입 멤버를 재구축하는 방식이다.
    - 이 방식으로 작업을 진행하려면 그룹 멤버들과 가입 멤버 모두 클론 플러그인이 설치되어 있어야 한다.

  그룹 복제의 분산 복구에서는 가입한 멤버에 대해 가장 적합한 형태의 복구 방식을 자동으로 선택한다.
  만약, 가입한 멤버와 기존 그룹 멤버 간의 트랜잭션 갭이 크거나 혹은
  필요한 트랜잭션들 중 일부가 기존 그룹 멤버의 바이너리 로그 파일에 더이상 존재하지 않는 경우 원격 클론 방식으로 복구 작업을 시작한다.
  가입한 멤버와 기존 그룹 멤버 간 트랜잭션 갭이 작거나, 원격 플러그인이 설치돼 있지 않은 경우엔 바이너리 로그 복제 방식으로로 복구한다.

  원격 클론 방식에선 가입한 멤버의 기존 데이터는 모두 제거되며 클론 작업으로 연결된 기존 그룹 멤버의 스냅샷 데이터가 저장된다.
  스냅샷 데이터로 복구되면 클론 작업 동안 그룹에 적용된 트랜잭션을 가져오기 위해 바이너리 로그 복제 방식으로 한번 더 복구 작업을 진행한다.

  트랜잭션 갭의 임곗값은 group_replication_clone_threshold 변수의 값을 확인하면 된다.
  이 시스템 변수의 기본값은 아주 큰 값이므로, 바이너리 로그 복제 방식이 가능한 환경에선 원격 클론 방식이 사용되지 않는다.
  따라서 원격 클론 방식을 사용하고 싶으면 해당 변수의 값을 적절히 조절해야 된다. (그렇다고 너무 작은 값은 안 됨)
 */

#### 17.2.6.2 - 분산 복구 프로세스
/**
  분산 복구 작업은 크게 세 단계로 나눌 수 있다.

  1. 로컬 복구
    가입 멤버가 이전에 그룹에 가입한 적이 잇는 경우 릴레이 로그에 적용하지 못한 트랜잭션이 존재할 수도 있다.
    이 트랜잭션들을 먼저 적용한 후 복구 작업 시작

  2. 글로벌 복구
    가입 멤버는 기존 멤버들에서 기증자 역할을 할 멤버를 선택해서 해당 멤버로부터 데이터 또는 누락된 트랜잭션들을 가져와 자신에게 적용
    이 작업을 진행하는 동안 그룹에서 처리되는 트랜잭션들을 내부적으로 캐싱해둔다.
        (기증자 멤버는 무작위로 선정)

  3. 캐시 트랜잭션 적용
    2단계(글로벌 복구)가 완료되면 캐싱해서 보관하던 트랜잭션들을 적용한 뒤 그룹에 참여한다.

  원격 클론 방식에서 가입 멤버는 무작위로 선택한 기증자 멤버의 스냅샷 데이터를 모두 전달받으면
  MySQL 서버를 재시작한다. 이때 서버에 group_replication_start_on_boot 변수의 값이 ON으로 설정되어 있으면
  재시작할 때 그룹 복제가 자동으로 시작되고, 바이너리 로그 복제 방식의 분산 복구가 진행된다.
  만약, OFF 이면 사용자가 수동으로 START GROUP_REPLICATION 명령을 실행해야 한다.

  바이너리 로그 복제 복구 방식에서는 가입 멤버가 그룹에 참여한 시점까지만 복구 작업을 진행하며,
  가입 멤버는 복구 작업 동안 그룹에서 처리된 트랜잭션들을 캐싱한다.
  가입 멤버가 그룹에 참여한 시점은 뷰 변경 로그 이벤트를 통해 알 수 있다.
  기증자 멤버에서 누락된 트랜잭션들을 가져와서 적용하다가 가입 멤버가 그룹에 참여했을 때 해당되는 뷰 번경 로그 이벤트를 만나면
  복제를 중지하고 캐싱된 트랜잭션을 적용하는 것으로 전환한다.
 */

#### 17.2.6.3 - 분산 복구 설정
/**
  다음과 같은 부분들을 필요에 맞게 설정할 수 있다.

  - 연결 시도 횟수
    group_replication_recovery_retry_count 변수를 통해 바이너리 로그 복제 방식으로 복구 작업시
    가입한 멤버가 기존 그룹 멤버에 연결을 시도하는 횟수를 제한할 수 있다. (기본값 10, 최대 31636000)
    원격 클론 방식은 이 제한이 적용되지 않으며, 연결 후보 멤버들에 대해서는 한 번씩만 연결을 시도한다.

  - 연결 시도 간격
    group_replication_recovery_reconnect_interval 벼수를 통해 바이너리 로그 복제 방식으로 복구 작업시
    기존 그룹 멤버들에 대한 연결 시도 사이의 대기 시간을 지정할 수 있다. (기본값 60초)
    원격 클론 방식에선 적용되지 않음

  - 가입한 멤버를 온라인 상태로 표기하는 시점
    기본적으로 가입한 멤버에서 분산 복구가 완료되면 즉, 누락된 트랜잭션들이 모두 적용되고 나면 가입한 멤버의 상태를 ONLINE으로 표시한다.
    가입한 멤버에서 누락된 트랜잭션들이 인증 단계까지 모두 완료했을 때 가입한 멤버의 상태를 ONLINE으로 표시되도록 설정할 수 있다.
    이는 group_replication_recovery_complete_at 변수의 값을 TRANSACTIONS_CERTIFIED로 설정하면 된다.
    기본값은 TRANSACTIONS_APPLIED 이다.

  이 값들은 복제가 실행되는 동안 값을 변경할 수는 있찌만 적용하려면 그룹 복제를 중지 후 다시 실행해야 한다.
 */

#### 17.2.6.4 - 분산 복구 오류 처리
/**
  다음과 같은 경우들에서 분산 복구는 자동으로 새로운 그룹 멤버로 연결을 전환해서 다시 작업을 시도한다.

  - 기증자로 선택한 그룹 멤버로의 연결이 인증 문제 등으로 인해 정상적으로 이뤄지지 않는 경우
  - 바이너리 로그 복제 방식으로 복구 작업을 진행하던 중 레플리케이션 I/O 스레드, SQL 스레드에서 에러가 발생하는 경우
  - 원격 클론 작업이 실패하거나 완료되기 전에 중단된 경우
  - 복구 작업 동안 기증자 멤버에서 그룹 복제가 중단된 경우

  performance_schema.replication_connection_status 또는 replication_applier_status_by_worker 테이블에서
  'LAST_ERROR_'로 시작하는 컬럼들로부터 바이너리 로그 복제 방식의 분산 복구와 관련해 가장 최근 에러를 확인할 수 있다.

  원격 클론 방식의 분산 복구 작업의 경우 performance_schema.clone_progress 및 clone_status 테이블을 확인하면 된다.

  다음과 같은 경우엔 분산 복구가 더이상 진행될 수 없으며, 가입 멤버는 그룹을 떠나게 된다.
    - 가입 멤버가 group_replication_recovery_retry_count 변수의 지정된 재시도 횟수를 모두 소진한 경우

    - 가입 멤버에 필요한 트랜잭션이 그룹 멤버들의 바이너리 로그에 존재하지 않으며,
      원격 클론 방식으로도 복구 작업을 진행할 수 없는 경우

    - 가입 멤버가 그룹에서는 존재하지 않는 트랜잭션을 가지고 있는 상태에서
      바이너리 로그 복제 방식으로 복구 작업이 진행되는 경우

    - 복구 작업이 진행되는 중에 가입 멤버에서 그룹 복제가 중단된 경우

  위에서 봤듯이 복구 작업 중에 직접 그룹을 탈퇴한 경우를 제외한 나머지 가입 멤버들은
  최종적으로 group_replication_exit_state_action 변수에 지정된 작업을 수행해야 한다.
 */
-- 바이너리 로그 복제 방식의 분산 복구에서 기증자 멤버로의 연결이 실패한 경우 보여지는 에러를 확인하는 쿼리
SELECT channel_name, last_error_number, last_error_message, last_error_timestamp
FROM performance_schema.replication_connection_status
where channel_name = 'group_replication_recovery';

### 17.2.7 - 그룹 복제 요구사항
/**
  그룹 복제를 사용하려는 MySQL 서버들은 다음 요구사항들을 충족해야 한다.

    - InnoDB 스토리지 엔진 사용
        데이터가 저장되는 테이블은 반드시 InnoDB 스토리지 엔진을 사용해야 한다.
        트랜잭션 처리를 위해서 (다른 스토리지 엔진은 에러 발생)

    - 프라이머리 키 사용
        그룹에서 복제될 모든 테이블들은 프라이머리 키를 가지고 있어야 하며,
        명시적인 프라이머리 키가 없다면 NOT NULL + 유니크 키가 반드시 테이블에 존재해야 한다.
        이러한 키들은 테이블 내의 모든 데이터에 대해 고유한 식별자 역할을 하며,
        그룹 복제에선 이를 바탕으로 트랜잭션 간의 충돌을 감지한다.

    - 원활한 네트워크 통신 환경
        그룹 멤버들간의 양방향 통신을 하므로 성능과 안정성은 네트워크 환경에 영향을 받는다.

    - 바이너리 로그 활성화
        기존 MySQL 복제와 마찬가지로 복제에서 바이너리 로그를 사용하므로 바이너리 로그가 활성화 되어 있어야 한다.
        8.0 버전부터 기본적으로 활성화 되어 있다.

    - ROW 형태의 바이너리 로그 포맷 사용
        ROW 포맷 기반의 복제를 사용해 트랜잭션으로 변경된 데이터가 그룹 멤버들에서 일관되게 적용될 수 있게 한다.

    - 바이너리 로그 체크섬 설정
        8.0.20 버전까지 바이너리 로그 체크섬 기능을 지원하지 않아 binlog_checksum 변수의 값을 NONE으로 설정했지만,
        8.0.21 버전부터 체크섬 기능을 지원하므로 해당 변수에 사용자가 원하는 값을 설정할 수 있다.

    - log_slave_updates 활성화
        새로운 멤버가 그룹에 참여하면 분산 복구 작업을 수행하는데,
        이때 기존 그룹 멤버의 바이너리 로그를 복제해서 자신에게 적용하므로
        그룹에서 발생한 트랜잭션들을 모두 각자의 바이너리 로그에 기록해야 한다.
        또한, 그룹 복제에서 그룹의 모든 멤버들이 쓰기를 수행하는 서버가 될 수 있으므로 해당 변수가 반드시 활성화 돼야 한다.

    - GTID 사용
        그룹 복제는 기본적으로 GTID를 사용하므로 그룹 복제를 설정할 MySQL 서버에서는 GTID를 활성화 시켜야 한다.

    - 고유한 server_id 사용
        복제에 참여하는 서버들은 고유한 server_id 값을 가져야 한다.

    - 복제 메타데이터 저장소 설정
        그룹 복제에서 복제 관련 메타데이터는 데이터 일관성을 위해 파일이 아닌 테이블에 저장돼야 한다.
        따라서 master_info_repository 및 relay_log_info_repository 변수의 값이 TABLE로 설정되어 있어야 한다.

    - 트랜잭션 WriteSet 설정
        트랜잭션에서 변경한 데이터에 대한 정보, 트랜잭션의 WriteSet이 수집될 수 있도록
        transaction_write_set_extraction 변수가 XXHASH64로 설정돼야 한다.
        WriteSEt은 그룹 복제에서 트랜잭션 간 충돌을 탐지하는 트랜잭션 인증 단계에서 사용한다.

    - 테이블 스페이스 암호화 설정
        default_table_encryption 변수는 모든 그룹 멤버에서 동일한 값으로 설정돼야 한다.

    - lower_case_table_names 설정
        lower_case_table_names 변수는 모든 그룹 멤버에서 동일한 값으로 설정돼야 한다.

    - 멀티 스레드 복제 설정
        그룹 복제도 멀티 스레드 복제 기능을 사용해 트랜잭션을 병렬로 적용할 수 있다.
        이때 복제 트랜잭션이 멀티 스레드로 적용될 때 원본 서버에서 커밋된 순서와 동일한 순서로 커밋되도록 반드시
        slave_preserve_commit_order 옵션을 ON(1)으로 설정해야 한다.
        만약, 멀티 스레드 복제 기능을 사용하고자 한다면 다음과 같이 설정하는 것이 좋다.
        [mysqld]
        slave_parallel_workers=N
        slave_parallel_type=LOGICAL_CLOCK
        slave_preserve_commit_order=1
 */

### 17.2.8 - 그룹 복제 제약 사항
/**
  그룹 복제는 다음과 같은 제약 사항이 있다. 또한, GTID를 사용하므로 GTID의 제약 사항에도 영향을 받는다.

  - 갭 락(Gap Lock)은 갭 락을 발생시킨 트랜잭션이 실행된 멤버에서만 유효하며,
    그룹 복제의 트랜잭션 인증 단계에서 해당 락 정보는 공유되지 않는다.
    따라서, 멀티 프라이머리 모드로 동작하는 그룹에서는
    멤버 로컬에서의 트랜잭션 충돌 감지와 그룹 복제에서의 트랜잭션 충돌 감지 수준을 일치시키기 위해 갭락이 사용되지 않는
    READ-COMMITTED 트랜잭션 격리 수준을 사용하는 것이 좋다.

  - 테이블 락(Table Lock) 및 네임드 락(Named Lock)도 그룹 단위로 락 정보가 공유되지 않는다.
    즉, 그룹 복제의 인증 단계에서는 이 두락을 고려하지 않는다.

  - 그룹 복제에서 바이너리 로그 체크섬 기능은 8.0.21 버전부터 사용 가능 (그 이전 버전에선 지원하지 않음)

  - 멀티 프라이머리 모드로 동작 중인 그룹에서는 SERIALIZABLE 트랜잭션 격리 수준을 사용할 수 없다.

  - 멀티 프라이머리 모드로 동작 중인 그룹에서 동일한 테이블에 대해 서로 다른 멤버에서 동시에 실행되는
    DDL 및 DML 문은 지원하지 않는다.

  - 멀티 프라이머리 모드로 동작 중인 그룹에서 외래키(FK)가 존재하는 테이블,
    특히 CASCADE 제약 조건이 사용된 테이블은 지원하지 않는다.
    CASCADE 제약 조건은 계단식 데이터 변경 작업을 유발하며, 이로 인해 감지되지 않는 트랜잭션 충돌이 발생하고,
    그룹 멤버 간에 데이터가 일치하지 않을 수 있다.
    따라서 이 같은 문제를 방지하기 위해 멀티 프라이머리 모드 그룹의 멤버들에서
    group_replication_enforce_update_everywhere_checks 변수를 활성화 하는 것이 좋다.
    해당 변수를 활성화 하면 그룹 복제에서는 실행된 쿼리들에 대해 멀티 프라이머리 모드와 호환되지는지 검사한다.
    싱글 프라이머리 모드에선 한 멤버에서만 쓰기가 허용되므로 데이터 일관성을 해칠 수 있는 문제는 발생하지 않는다.
    따라서, 싱글 프라이머리 모드에선 위 변수를 OFF 해놓자.

  - 멀티 프라이머리 모드에서 SELECT ... FRO UPDATE 구문을 사용할 때 데드락이 발생할 수 있다.

  - 그룹 복제에서 복제 필터 기능은 사용할 수 없다.
    그룹 멤버가 그룹 외부의 다른 소스 서버에 대한 일반 복제도 함께 진행하는 경우 일반 복제에 대한 필터링은 적용 가능.

  - 그룹 복제는 최대 9대의 서버까지 구성 가능하다.
    이미 9대로 구성된 그룹 복제에서 새로 멤버가 추가되는 경우에는 에러가 발생한다.
 */
