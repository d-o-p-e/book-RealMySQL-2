## 11.5 INSERT
insert에서는 테이블 구조가 성능에 영향을 크게미친다.

### 11.5.1 고급옵션

#### 11.5.1.1 INSERT IGNORE

Q. 진우 INSERT IGNORE 는 어떻게 동작할까요?

> INSERT IGNORE 옵션은 저장하는 레코드의 프라이머리 키나 유니크 인덱스 중복이 일어나거나 컬럼이 호환되지 않는 경우 무시하고 다음 레코드를 처리할 수 있게 해준다.

-> 기존 에러를 간단한 경고 수준으로 바꿈

Q. 건환 INSERT IGNORE 옵션을 사용하여 NOT NULL 컬럼에 NULL 값을 입력하면 어떻게 되는가?
> 경고와 함께 NULL 값이 DATA TYPE에 따라 0으로 입력된다.

Q. 건환 UNIQUE 인덱스 컬럼에 중복값이 INSERT 되었을 때 중복된 값에 INSERT 대신 UPDATE를 수행해주는 옵션은?
> ON DUPLICATE KEY UPDATE

#### 11.5.1.2 INSERT ... ON DUPLICATE KEY UPDATE

Q. 진우 INSERT ... ON DUPLICATE KEY UPDATE 는 어떻게 동작할까요?
> 프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATE 문장의 역할을 수행하게 해준다

### 11.5.2 LOAD DATA 명령 주의 사항

LOAD DATA 의 단점
- 단일 스레드
- 단일 트랜잭션

Q. 진우 LOAD DATA 처리의 단점으로는 단일 스레드, 단일 트랜잭션이 있는데, 이것이 어떻게 성능에 영향을 미치나요?
> 데이터가 크면
>
> -> 단일스레드라 느리고
>
> -> 트랜잭션이 길게 유지될 수 있음.
>
> -> 언두로그 쌓임
>
> -> 전체적인 성능이슈 발생

해결방법: 파일 여러개로 나눠서 여러 트랜잭션 & 스레드에서 실행

진우 Q. LOAD DATA 명령이 INSERT에 비해 빠른 이유는?
> 내부적으로 MySQL 엔진과 스토리지 엔진의 호출 횟수를 최소화하고, 스토리지 엔진이 직접 데이터를 적재하기 때문에

진우 Q. LOAD DATA 명령의 단점은?
> 단일 스레드이므로 적재해야할 데이터 파일이 매우 크다면 시간이 매우 길어질 수 있음.
> 단일 트랜잭션이기 때문에 Undo Log가 삭제되지 못하고 유지돼야 함.

기현 Q. 데이터를 빠르게 저장하는 다른 방법은 뭐가 있을까?

> 기존에 존재하는 테이블이라면 인덱스 및 FK를 비활성화 시킨 후 INSERT. 신규 테이블이라면 데이터 삽입 이후 인덱스 생성

기현 Q. OLTP 환경에서 PK는 insert / select 중 어느 작업을 위한 컬럼을 생성하는게 좋을까

> SELECT 작업을 위해, 대부분의 작업이 select이기 때문

### 11.5.3 성능을 위한 테이블 구조

#### 11.5.3.1 대량 INSERT 성능

하나의 INSERT 문장으로 수천 건의 레코드를 INSERT 한다면 INSERT 될 레코드들을 프라이머리 키 값 기준으로 미리 정렬해서 INSERT 문장을 구성하는 것이 성능에 도움이 될 수 있다

Q. 왜그럴까요?
> 그렇지 않으면 매 레코드마다 B-Tree에서 이곳저곳 랜덤한 위치의 페이지를 메모리로 읽 어와야 하기 때문. 순서대로 읽으면 페이지에 캐싱될 확률이 높음
> 
> "공간적 지역성"

오래만에 들어보는 체인지 버퍼: 인덱스 업데이트 변경사항을 지연쓰기

#### 11.5.3.2 프라이머리 키 선정

PK선정 기준은,

비즈니스적으로 의미있는 PK를 사용하거나 OR 단조 증가/감소 하는 패턴의 값

Q. 진우 SELECT는 많지 않고 INSERT가 많은 테이블에 대해서는 인덱스의 개수를 (최대화/최소화)하는 것이 좋다.
> 최소화

Q. 건환 INSERT될 레코드를 프라이머리 키 기준으로 미리 정렬하여 INSERT문장을 구성한다면 성능에 도움이 된다. 그 이유는?
> 새로운 페이지를 메모리로 가지고 오지 않아도 레코드를 저장할 위치를 찾을 수 있기 때문에

#### 11.5.3.3 AUTO-Increment 칼럼

자동 증가 값을 PK로 쓰는 것은 가장 빠른 INSERT를 보장하는 방법이다.

+ 세컨더리 인덱스가 하나도 없는 테이블이라면 굳

건환 Q. SELECT 보다 INSERT에 최적화된 테이블을 생성하기 위한 방법 두가지는?
> AUTO_INCREMENT 칼럼 이용, 세컨더리 인덱스 최소화

## 11.6 UPDATE 와 DELETE

### 11.6.1 UPDATE ... ORDER BY ... LIMIT n

ORDER BY 절과 LINIT 절을 동시에 사용해 특정 칼럼 으로 정렬해서 상위 몇 건만 변경 및 삭제하는 것도 가능

-> 너무 많이 한 번에 제거하는 것은 과부하가 올 수 있으니, 조금씩 잘라서 삭제하는 방식

### 11.6.2 JOIN UPDATE

두 개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭제

락을 거는 테이블/컬럼이 여러개니까, 데드락 유발 주의!

Q. 건환 JOIN UPDATE가 OLTP환경보다 배치 프로그램이나 통계용 UPDATE 문장에서 더 유용하게 사용할 수 있는 이유는 ?
> JOIN UPDATE의 경우 OLTP성환경에서 데드락 유발 과 읽기잠금, 쓰기잠금이 발생하기 때문에

### 11.6.3 여러 레코드 UPDATE

레코드를 생성해서 서로 다른 값을 업데이트하는 방식

내부에서 임시 테이블 생성해서 처리

Q. 건환 여러 레코드를 업데이트 할 때 UPDATE 문장과 Row Constructor 문장의 차이는?
> UPDATE문은 모든 레코드를 동일한 값으로만 업데이트 할 수 있고,
> Row Constructor 문은 SQL문장 내에서 임시테이블을 생성 하여 JOIN UPDATE를 수행하기 때문에 여러 레코드를 다양한 값으로 업데이트할 수 있음

### 11.6.4 JOIN DELETE

삭제할 테이블을 delete 에 명시해줘야함.

```
DELETE e, de
FROM employees e, dept_emp de, departments d
WHERE e.emp_no=de.emp_no AND de.dept_no=d.dept_no AND d.dept_no='d001';
```

### 11.7.1 - 온라인 DDL

민석님이 저자분 글을 공유해주셨다.
https://medium.com/daangn/mysql-online-ddl-faf47439084c

:테이블 구조를 변경하는 동안 DML 실행가능한 방식

#### 11.7.1.1 온라인 DDL 알고리즘

INSTANT : 테이블의 데이터는 전혀 변경하지 않고, 메타데이터만 변경하고 작업을 완료한다.

-> 정말 짧은 메타데이터 잠금

INPLACE: 임시 테이블로 데이터를 복사하지 않고 스키마 변경을 실행한다. 하지만 내부적으로는 테이블의 `리빌드`를 실행할 수도 있다.

-> PK를 추가하면 데이터 파일에서 레코드 저장 위치가 바뀌기 때문에 리빌드를 거친다.

건환 Q. MySQL 스키마 알고리즘(INSTANT, INPLACE, COPY) 을 간단히 설명하시오
> INSTANT : 테이블의 데이터를 변경하지 않고 메타데이터만 변경
> INPLACE : 임시테이블로 데이터를 복사하지 않고 스키마 변경을 실행.
> COPY : 변경된 스키마를 적용한 임시 테이블 생성

건환 Q. Online DDL 수행 옵션 중 LOCK 옵션 (NONE, SHARED, EXCLUSIVE)를 간단히 설명하시오
> NONE : 아무런 잠금을 걸지 않음
> SHARED : 읽기 잠금을 걸고 스키마 변경 실행 (읽기는 가능하지만 INSERT,UPDATE, DELETE 불가)
> EXCLUSIVE : 쓰기 잠금을 걸고 스키마 변경 실행 (읽기 및 쓰기 불가)

#### 11.7.1.2 온라인 처리 가능한 스키마 변경
온라인 DDL이라 하더라도 부하를 유발할 수 있으며, 그로 인해 다 른 커넥션의 쿼리들이 느려질 수도 있다. 그러므로 설령 스키마 변경 작업이 직접 다른 커넥션의 DML을 대기하게 만들지는 않더라도 주의해서 사용해야 한다.

#### 11.7.1.3 INPLACE 알고리즘

테이블 구조 변경 도중 데이터 업데이트 사항들을 트래킹하고, 테이블 변경 이후 반영.

온라인 변경 로그(online after log) 라는 메모리 공간에 변경사항들을 잠시 저장함.

#### 11.7.1.4 온라인 DDL 의 실패 케이스


#### 11.7.1.5 온라인 DDL 진행 상황 모니터링
온라인 DDL 진행사항 체크 가능.

끝난 레코드 / 남은 레코드

### 11.7.3 테이블 스페이스 변경
테이블 스페이스란: 테이블, 인덱스, 프로시저, 뷰 등의 객체들을 저장해놓은 논리적 공간

제너럴 테이블 스페이스: 여러 테이블 데이터를 한 번에 저장하는 테이블 스페이스

제너럴 테이블 스페이스는 테이블이 엄청 많은 경우 관리 측면에서 유용함.

#### 11.7.4.3 테이블 구조 변경

다음은 스토리지 엔진 변경하는 명령

```sql
ALTER TABLE employees ENGINE=InnoDB,
ALGORITHM=INPLACE, LOCK=NONE;
```

또한 테이블 데이터를 수동으로 리빌드 하는 목적으로도 사용 됨.

삭제가 자주 일어나서 데이터 파편화 현상이 생기면, 이런 빈 공간을 제거해서 디스크 사용 공간을 확보.

#### 11.7.4.4 테이블 명 변경

때로는 일정 주기마다 배치를 통해 테이블을 교체하는데, 이럴때 순간 테이블이 없어지는 현상 발생.

-> RENAME TABLE 명령 사용!

```sql
RENAME TABLE batch TO batch_old,
batch_new TO batch;

```
락이 발생하지만, 실패처리가 되는게 아니라 잠깐의 잠금 대기.

기현 Q. rename table 사용시 해당 테이블을 참조하는 fk도 변경될까?

> 테이블 구조 복사
>
> 위의 쿼리를 수행하면 모든 컬럼과 인덱스를 동일하게 생성한다.
> CREATE TABLE temp_test LIKE test;

기현 Q. CREATE TABLE .. LIKE 구문 수행시 FK도 생성될까?

> NO


#### 11.7.4.5 테이블 상태 조회
- information_schema 데이터베이스에는 MySQL 서버가 가진 스키마들에 대한 메타 정보를 가진 딕셔너 리 테이블이 관리된다.

- inforation_schema 에 존재하는 테이블들은 실제로 존재하는 테이 블이 아니라  다양한 메타 정보를 모아서 메모리에 모아둔 테이블

#### 11.7.4.6 테이블 구조 복사

`LIKE`

```
CREATE TABLE temp_employees LIKE employees;
```

#### 11.7.4.7 테이블 삭제

디스크에서 파일의 조각들이 너무 분산되어있다면 많은 디스크 읽고 쓰기 작업이 필요하다.

MySOL 서버의 디스크 읽고 쓰기 부하가 높아지면 다른 커넥션의 쿼리 처리 성능이 떨어질 수도 있다.

어뎁티브 해시 인덱스를 사용했었다면, 어뎁티브 해시 인덱스를 따로 삭제해줘야한다.

어뎁티브 인덱스
- 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스.
- 버퍼풀에 있는 페이지만을 대상으로 해시 인덱싱 함
- 즉 자주 사용되는 데이터를 대상으로, 버퍼풀 내에서의 접근을 빠르게 도와준다.

#### 11.7.5.1 칼럼 추가

컬럼을 마지막에 추가: 리빌드 없이 INSTANT 처리

컬럼을 중간에 추가: INPLACE로 처리하면서 리빌드 필요

#### 11.7.5.2 칼럼 삭제

항상 inplace 리빌드 필요.

#### 11.7.5.3 칼럼 이름 및 칼럼 타입 변경

Q. 칼럼 타입 변경에서 어떤 경우에 리빌드가 필요한가요?
> 사용해야하는 데이터 타입의 크기가 할당 사이즈보다 늘어나면 리빌드가 필요하다.

#### 11.7.6.2 인덱스 조회

#### 11.7.6.3 인덱스 이름 변경

#### 11.7.6.4 인덱스 가시성 변경

ivisible을 통해 테이블의 특정 인덱스를 무시할 수 있음.

-> 모니터링 이후에 안전하게 삭제

```sql
ALTER TABLE employees ALTER INDEX ix_firstname INVISIBLE;
```

#### 11.7.6 테이블 변경 묶음 실행

### 11.7.8 프로세스 조회 및 강제 종료

Q. 트랜잭션이 종료되지 않고 오랫동안 활성상태로 남아있는 경우 MySQL 성능에 악 영향을 미치는 이유는?

> mvcc undo log 크기가 늘어나, 디스크 용량 및 조회시 오버헤드 발생

진우 Q. 두 쿼리의 차이점?
> 1. 쿼리는 강제 종료 시키지만 커넥션은 그대로
> - 응용 프로그램에서 쿼리의 에러를 감지해서 트랜잭션 을 롤백하게 돼 있다면 다음과 같이 쿼리만 종료하면 된다.
> 2. 커넥션까지 강제 종료
> - 응용 프로그램에서 쿼리 에러에 대한 핸들링이 확실하지 않다면 쿼리를 종료시키는 것보다 커넥션 자체를 강제 종료시키는 방법이 더 안정적일 수 있다.

```sql
KILL QUERY 4228;
KILL 4228;
```

건환 Q. SHOW PROCESSLIST 명령어를 사용하여 나타나는 레코드 수는, MySQL 서버에 접속된 클라이언트의 요청을 처리하는 ()의 수이다.
> 스레드

건환 Q. 특정 스레드에서 실행중인 쿼리나 커넥션 자체를 강제 종료하려면 () 명령어를 사용하면 된다.
> kill

### 11.8.1 - 쿼리의 성능에 영향을 미치는 요소

건환 Q. InnODB 스토리지 엔진은 파일 시스템의 캐시나 버퍼를 거치지 않는 ()를 사용한다
> Direct I/O

건환 Q. InnoDB 버퍼 풀은 MySQL 서버가 종료될 때 자동으로 덤프됐다가 다시 시작될 때 자동으로 적재된다 (O/X)
> O


#### 11.8.1.1 - 운영체제의 캐시

InnoDB 스토리지 엔진은 일반적으로 파일 시스템의 캐시나 버퍼를 거치지 않는 Direct T/o 를 사용하므로 운영체제의 캐시가 그다지 큰 영향을 미치지 않는다.

#### 11.8.1.2 - MySQL 서버의 버퍼 풀(InnoDB 버퍼 풀과 MyISAM의 키 캐시)

#### 11.8.1.3 - 독립된 MySQL 서버

#### 11.8.1.4 - 쿼리 테스트 횟수
