https://velog.io/@minstone/Real-MySQL8.0-11.-%EC%BF%BC%EB%A6%AC-%EC%9E%91%EC%84%B1-%EB%B0%8F-%EC%B5%9C%EC%A0%81%ED%99%942-hxr7l5fk

11.5.1.1 INSERT IGNORE
PK,UK 컬럼의 값이 INSERT문의 레코드와 중복되는 경우, 모두 무시하고 다음 레코드를 처리한다.
중복레코드 말고도 타입이 일치하지 않는경우도 컬럼의 기본값으로 삽입한다.

11.5.1.2 INSERT ...ON DUPLICATE KEY UPDATE
ansi 표준 merge문과 비슷하다.
키 기준으로 존재하면 update, 없으면 insert 작업을 수행한다.

11.5.2 LOAD DATA 명령 주의 사항
MySQL엔진과 Storage엔진 호출을 최소화 해 일반적인 INSERT문과 비교시 속도에서 우위이다.
단일스레드 / 단일트랜잭션으로 실행되기에, 트랜잭션이 길어진다면 다른 온라인 트랜잭션쿼리 성능에 영향을 줄 수 있다.
같은 이유로 트랜잭션이 길어지기에, 언두가 삭제되지 않고 유지되어 디스크상, 언두처리 성능에 영향을 준다.

11.5.3.1 대량 INSERT 성능 / 11.5.3.2 프라이머리 키 선정 / 11.5.3.3 Auto-Increment 컬럼
PK값으로 정렬하여 INSERT작업 시 정렬안하고 작업하는것과 큰 성능차이를 보인다.
INSERT와 SELECT의 성능을 모두 고려하여 키를 지정하면 더할나위없이 좋지만, 보통은 두가지 요소중 한개를 선택하게 된다.
현 직장에서는 PK를 AUTO_INCREMENT BIGINT 로 기본설정하고 있다.
자동 증가값을 사용하면 값이 커질때 b-tree 특성으로 인덱스가 우편향 될 수 있는데, 성능이 안나온다면 재정렬 작업이 필요 할 수 있다.


11.6.1 UPDATE ...ORDER BY ...LIMIT n
ORDER BY 절과 LIMIT 절을 통해 특정 컬럼으로 정렬 후 상위 몇건만 UPDATE 작업을 수행 할 수 있다.

11.6.2 JOIN UPDATE / 11.6.3 여러 레코드 UPDATE
두개 이상테이블을 조인해 결과 레코드를 변경 및 삭제 할 수 있다.
참조테이블은 읽기잠금, 변경테이블은 쓰기잠금을 획득해 데드락 유발가능성이 있어 OLTP환경에는 부적합하다.
조인순서에 따라 UPDATE 성능이 달라질 수 있어, 실행계획을 확인하는것이 좋다.
"VALUES ROW(...), ROW(...), ..." 문법을 사용하면 임시테이블을 생성하는 효과가 있음며, 조인해 업데이트 결과를 낼 수 있다.

11.7.1 온라인 DDL
Online DDL을 사용하는 이유는 스키마 변경을 실행하는 중에도 INSERT나 UPDATE와 같은 DML이 실행될 수 있도록 하기 위함
pt-osc, ghost-osc 와같은 서드파티툴을 많이 사용했지만, MySQL8.0 에서는 Online DDL로 대부분 처리가능하다 -> osc들 한번 정리해서 공유드리겠습니다.
Online DDL 및 UNIQUE KEY 관련 이슈
https://medium.com/daangn/mysql-online-ddl-faf47439084c


11.7.1.1 Online DDL 알고리즘
INSTANT
테이블의 데이터는 변경하지 않고, 메타데이터만 변경함.
아주 짧은시간 동안만 락이잡혀, 쿼리에 크게 영향주지 않는다.
INPLACE
임시테이블로 데이터를 복사하지 않고, 스키마 변경을 실행한다.
내부적으로 리빌드를 수행 할 수 있으며, 많은시간이 소요될수도 있지만 작업중 읽기와 쓰기 모두 가능하다.
COPY
변경된 스키마가 반영된 임시테이블을 생성하고 데이터를 복사 한 후 RENAME해 스키마 변경한다.

작업중 읽기작업만 가능하다.

pt-osc의 경우 COPY 알고리즘을 베이스로 두며 트리거 및 청크데이터를 통해 DML작업을 가능하게한다.

ONLINE DDL의 지원범위는 변경될 수 있기에 공식 메뉴얼을 참고하여 최신정보를 확인하자. https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html

ONLINE DDL을 지원하는지, 어떤알고리즘을 사용하는지 모든 DDL작업에 대해 외울 수 없다. 이럴때 알고리즘을 강제하여 ONLINE DDL 지원여부를 확인할 수 있다 (171p).


11.7.1.4 온라인 DDL의 실패 케이스
INPLACE 알고리즘을 사용하는 경우 리빌드로 많은 시간이 걸릴 수 있는데, 많은 DML, 온라인 변경 로그의 공간부족으로 실패 할 수 있다.

11.7.1.5 온라인 DDL 진행 상황 모니터링
performace_schema가 활성화 및 instrument, consumer 옵션이 활성화 되어있어야 한다.
event_stages_current 테이블로 진행상황을 예측 할 수 있다. 진행률은 (WORK_COMPRLETED * 100 / WORK_ESTIMATED)로 대략적으로 확인 가능하다.

11.7.4.2 테이블 구조 조회
SHOW CREATE TABLE ... 문장은 컬럼목록과 키정보, 콜레이션정보와 같은 전체적인 구조를
DESC문장은 컬럼정보와 같은 대략정인 정보를 제공한다.

11.7.4.4 테이블 명 변경
RENAME TABLE 명령을 사용하며 메타정보만 변경하기에 아주 짧은시간의 락만 잡힌다.
여러테이블의 RENAME명령을 하나의 문장으로 묶어 실행 할 수 있다.

11.7.4.5 테이블상태 조회
SHOW TABLE STATUS를 통해 엔진, 레코드수, 콜레이션 등을 확인 가능한데,
제공하는 레코드수의 경우는 대략적인 값이니 무조건 신뢰하기엔 어려움이 있다. (앞선 내용처럼 INNODB는 건수를 메타로 저장하지 않는다.)

11.7.6 인덱스 변경 / 11.7.6.4 인덱스 가시성 변경
MySQL8.0 버전부터 대부분의 인덱스 변경 작업이 ONLINE DDL로 처리 가능하다.
스파샬, 전문과 같은 인덱스 추가에는 shared 잠금이 필요하지만, b-tree를 사용하는 인덱스는 pk이여도 잠금없이 인덱스 생성이 가능하다.
인덱스를 불필욯하다 판단하고 삭제했지만, 필요에 의해 재생성하는경우 많은 리소스가 소비될 수 있다.
이런경우 인덱스를 "사용안함" 처리 할 수있는 INVISIBLE 옵션이 있다. 반대로 "사용"처리하려면 VISIBLE 옵션을 명시하면된다.

11.7.8 프로세스 조회 및 강제 종료
SHOW PROCESSLIST 명령을 통해 각 클라이언트 사용자가 어떤 쿼리를 사용하는지, 상태에 있는지 확인 가능하다.
KILL명령으로 ID를 사용하여 쿼리나 커넥션을 중단할 수 있다.
SHOW PROCESSLIST 의 경우 긴 쿼리는 잘려나오게 됩니다.
information_schema.PROCESSLIST 테이블을 조회하면 쿼리 전문으로 조회 가능합니다.