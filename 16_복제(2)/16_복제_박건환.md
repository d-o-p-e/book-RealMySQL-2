## 16.6 복제 토폴로지

- 싱글 레플리카 복제구성 : 일반적으로 소스 서버가 읽기/쓰기 연산을 모두 처리하며, 레플리카는 예비용 서버로 활용
- 멀티 레플리카 복제구성 : 2대 이상의 레플리카를 두는 형태이다. 대부분의 서비스에서 발생하는 요청은 쓰기 요청보다 읽기 요청이 많다
- 체인 복제 구성 : 레플리카 서버가 많아져 소스 서버가 바이너리 로그를 읽고 전송하는 작업에 부하가 걸릴 때 이를 해소하기 위한 복제 구성
- 듀얼 소스 복제 구성 : 두 개의 데이터베이스 서버가 서로의 소스 서버이자 레플리카 서버인 구성
- 멀티 소스 복제 구성 : 하나의 레플리카 서버가 다수의 소스 서버를 갖는 구성


## 16.7 복제 고급 설정

Q. 지연된 복제를 사용하는 이유는 ?
> 문제 발생시 좀 더 유연하게 대처하기 위해
> 데이터 반영에 지연이 있을 때 발생하는 서비스 동작을 테스트하기 위해

### 16.7.2 멀티 스레드 복제 
Q. 멀티 스레드 복제에서 릴레이 로그를 읽어 워커스레드와 협업하여 동기화를 진행하는 스레드 명은?
>  코디네이터 스레드

Q. DATABASE 기반 멀티스레드 복제와 LOGICAL CLOCK 기반 멀티 스레드 복제의 가장 큰 차이점은 ?
> 데이터베이스 기반 복제는 데이터베이스에 종속되어 처리되지만, LOGICAL CLOCK 기반 복제는 소스 서버로부터 넘어온 트랜잭션 전체를 멀티 스레드로 처리

Q. 바이너리 로그 커밋 3단계는 ?
> Flush 단계 : 대기 큐에 등록된 각트랜잭션들을 순서대로 바이너리 로그에 기록
> Sync 단계 : 앞서 기록된 바이너리 로그 내용들을 디스크와 동기화하는 fsync() 시스템 콜 수행
> Commit 단계 : 대기 큐에 등록된 트랜잭션들에 대해 스토리지 앤진 커밋 진행

Q. Commit-parent 기반 LOGICAL CLOCK 방식, 잠금(Lock) 기반 LOGICAL CLOCK 방식, WriteSet 기반 LOGICAL CLOCK 방식의 차이는?
> Commit-parent 기반 LOGICAL CLOCK 방식 : 트랜잭션의 커밋 시점에 따라 복제를 처리하는 방법
> 잠금(Lock) 기반 LOGICAL CLOCK 방식 : 트랜잭션의 커밋 시점보다는 커밋 처리 시점이 겹치는 트랜잭션을 병렬로 처리하는 방식
> WriteSet 기반 LOGICAL CLOCK 방식 : 트랜잭션이 변경한 데이터를 기록하는 WriteSet을 사용하여 병렬 실행 여부를 결정

Q. MySQL 서버의 멀티 스레드 복제 환경에서, 각 워커 스레드가 실행한 이벤트의 포지션 정보가 어떻게 관리되는지 ?
> MySQL 서버의 mysql 데이터베이스 내 slave_worker_info 테이블 혹은 데이터 디렉터리 내의 worker-relay-log.info라는 파일에 각 스레드별로 저장

Q. relay_log_recovery=ON 옵션과 relay_log_info_repository=TABLE 옵션의 기능은 ?
> relay_log_recovery=ON : MySQL 서버가 비정상 종료 후 재구동될 때 I/O 스레드의 포지션을 SQL 스레드가 마지막으로 실행한 포지션으로 초기화하여 비정상 종료 이후에도 정상적인 복제를 시작할 수 있게 하는 기능
> relay_log_info_repository=TABLE : I/O 스레드의 포지션 정보를 InnoDB 엔진을 사용하여 TABLE 형태로 관리(slave_master_info, slave_relay_log_info)

### 16.7.4 필터링된 복제( Filtered Replication)
Q. 필터링된 복제란 ?
> 소스 서버의 특정 이벤트들만 리카 서버에 적용될 수 있도록 해주는 기능
