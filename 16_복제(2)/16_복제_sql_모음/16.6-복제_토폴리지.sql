## 16.6 - 복제 토폴로지
-- 5.7 버전부터 멀티 소스 복제 기능이 도입되면서 하나의 레플리카 서버는 둘 이상의 소스 서버를 가질 수 없다는 제약 사항이 사라졌다.

### 16.6.1 - 싱글 레플리카 복제 구성
/**
  이 복제의 형태는 가장 기본적인 형태로 제일 많이 사용되는 형태이다.
  애플리케이션 서버는 소스 서베에만 직접적으로 접근해 사용하고, 레플리카 서버는 접근하지 않으며,
  장애가 발생했을 때 예비 서버 및 데이터 백업 수행을 위한 용도로 사용된다.
  서비스와는 연관이 없는 배치 작업이나 어드민 툴에서 사용되는 쿼리들은 레플리카 서버에서 실행되도록 구현해도 무방하다.
 */

### 16.6.2 - 멀티 레플리카 구성
/**
  멀티 레플리카 복제는 하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태이다.
  서비스 오픈 초기에는 DB 서버로 유입되는 쿼리 요청이 매우 적기 때문에 상관 없다가, 서비스의 트래픽이 증가해서 읽기 쿼리와 쓰기 쿼리를 분산시킬때 많이 사용한다.

  배치나 통계, 분석 등의 여러 작업이 하나의 MySQL 서버 내에 있는 데이터에 대해 수행돼야 하는 경우에도 멀티 레플리카 복제 방식이 도움이 된다.
  배치나 통계 등의 여러 용도로 나누어 사용하는 경우, 읽기 요청 분산으로 사용하는 경우 모두 레플리카 서버 한 대는 예비용으로 남겨두는 것이 좋다.
  한 대를 냅두는 이유는 장애가 발생했을 때 최대한 빠르게 복구하기 위해서 그렇다. ('결핍의 경제학' 미국 수술실 이야기가 생각이 났다. 음..)
    (모든 레플리카 서버가 어떠한 업무를 처리하는 중에 소스 서버의 장애로 인해 레플리카 서버가 승격하면 해당 레플리카의 업무는 다른 레플리카로 넘어가게 된다.
      근데, 이 상황에서 다른 레플리카서 서버는 자기의 일 처리도 많은데 넘겨진 쿼리 요청으로 인해 부하가 높아져 성능 저하가 발생할 수도 있다.
      이때 원래 레플리카가 하고 있던 처리와 더불어 넘겨진 쿼리 요청들 둘 모두 원활하게 처리되지 못할 수도 있다.
      이를 대비해 한 대를 예비용으로 두는 것이 효율적이다.)
 */

### 16.6.3 - 체인 복제 구성
/**
  멀티 레플리카 복제 구성에서 레플리카 서버가 너무 많아 소스 서버의 성능에 악영향이 예상된다면 1:M:M 구조의 체인 복제 구성을 고려해 볼 수 있다.

  소스 서버는 레플리카 서버가 '요청할 때마다' 계속 바이너리 로그를 읽어서 '전달'해야 한다.
  그래서, 하나의 소스 서버에 연결된 레플리카 서버 수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수 있다.
  해결할 수 있는 방법으로는 1차 복제 그룹과 2차 복제 그룹을 따로 두는 것이 있다.

  1차 복제 그룹
  웹 서버 -> 소스 1 -> 레플리카1-1, 레플리카2-1, 레플리카3-1/소스2

  2차 복제 그룹
  배치/분석 서버 -> 소스2 -> 레플리카2-1, 레플리카2-2

  이런 형태로 소스1의 레플리카 서버를 소스2 서버로 만들어 둔 뒤 해당 소스2 서버에 레플리카 서버를 추가하는 형태이다.
  이런식으로 사용하면 소스1 -> 레플리카1, 2, 3, 4, 5, ... n 으로 사용했을 때보단 소스1 서버의 바이너리 로그를 전달하는 과정을 줄일 수 있다.

  1차 복제 그룹에선 OLTP 서비스 용도
  2차 복제 그룹에선 통계나 배치, 백업 용도로 구분해서 사용할 수 있다.

  이러한 형태는 MySQL 서버를 업그레이드하거나 장비를 일괄 교체할 때도 많이 사용된다.
  기존 장비의 MySQL은 그대로 두고, 새로운 장비에 업그레이드한 MySQL을 설치하고 데이터를 신규 장비로 옮기는 형태의 업그레이드를 진행한다 했을 때
  위와 같이 구성된 복제 구조로 만들면 서비스의 멈춤 없이 진행할 수 있다.
  1차 복제 그룹
  '소스 1, 레플리카 1-1, 레플리카 1-2'는 기존 MySQL 서버,
  2차 복제 그룹
  '레플리카 1-3/소스2, 레플리카 2-1, 레플리카 2-2'는 업그레이드하려는 버전의 MySQL

  이와 같은 구조로 복제가 준비되면 웹 서버나 애플리케이션 서버에서 기존 MySQL 서버에 접속할 때 사용하던
  도메인 네임이나 IP 주소를 새로운 MySQL 서버로 바라보게끔 변경하고, 웹 서버나 애플리케이션 서버를 한 대씩 돌아가면서 재시작 하면 된다.
  재시작되 전의 서버들은 기존의 MySQL 서버로 접속해 쿼리를 실행하지만, 변경 내용은 모두 새로운 MySQL 서버로 자동으로 전달되니 걱정을 안해도 된다.
  웹 서버나 애플리케이션 서버가 전부 재시작 되면 기존 MySQL 3대는 모두 복제 그룹에서 제외시키면 된다.

  체인 형태의 복제를 구성하려면 레플리카 이면서 소스 서버의 역할을 하는 서버에서 반드시 바이너리 로그와 log_slave_updates 시스템 변수가 활성화 돼 있어야 한다.
  8.0.2 버전부터는 바이너리 로그와 log_slave_updates 변수는 기본적으로 활성화되어 있다. (기본값이 ON)
 */

-- 바이너리 로그 활성화 확인
show variables like 'log_bin';
SELECT @@log_bin;

-- log_slave_updates 활성화 확인
show variables like 'log_slave_updates';
SELECT @@log_slave_updates;

### 16.6.4 - 듀얼 소스 복제 구성
/**
  듀얼 소스 복제 구성은 두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버로 구성돼 있는 형태를 말한다.
  듀얼 소스 구성은 두 서버 모두 쓰기가 가능하다는 것이 제일 큰 특징이며, 양쪽에서 쓰기가 발생하지만 복제를 통해 두 서버는 동일한 데이터를 갖게 된다.

  듀얼 소스 구성에서 목적에 따라 두 서버를 ACTIVE-PASSIVE 또는 ACTIVE-ACTIVE 형태로 사용할 수 있다.

  ACTIVE-PASSIVE는 하나의 MySQL 서버에서만 쓰기 작업이 수행되는 형태인데, 싱글 레플리카 복제 구성과는 다르다.
  다른 이유는 예비 서버인 다른 MySQL 서버가 바로 쓰기 작업이 가능한 상태이기 때문에 쓰기 작업이 수행되고 있는 서버에서 문제 발생 시
  별도의 설정 변경 없이 바로 예비용 서버로 쓰기 작업을 전환할 수 있다.

  ACTIVE-ACTIVE는 두 서버 모두에 쓰기 작업을 수행하는 형태이다.
  지리적으로 매우 떨어진 위치에서 유입되는 쓰기 요청도 원할하게 처리하기 위해 주로 사용된다.
  서로 다른 지역에 MySQL 서버를 두고 각 지역에서 발생하는 쓰기 요청은 해당 지역에 위치한 MySQL 서버로 수행되게끔 구현하면 클라이언트 단에서는
  좀 더 빠르게 쓰기 처리를 완료할 수 있다.
  단, 서로의 트랜잭션이 전달 완료되어 적용하기 전까지 두 MySQL 서버는 일관되지 않은 데이터를 가질 수 있다.
 */

/**
  듀얼 소스 복제 구성을 사용할 때는 다음과 같은 부분에서 문제가 발생할 수 있음으로 주의해야 한다.
  - 동일한 데이터를 각 서버에서 변경
  - 테이블에서 Auto-Increment 키 사용

  동일한 데이터를 각 서버에서 변경될 때 - ACTIVE-ACTIVE 형태에서 동일한 데이터에 대한 변경 트랜잭션이 동시점에 유입되는 경우
  나중에 처리된 트랜잭션의 내용이 최종적으로 반영되는데, 이 경우 사용자가 예쌍하지 못한 방향으로 데이터가 처리될 수 있다.

  상품의 재고 수를 업데이트하는 쿼리가 있다고 가정해보자.
  비슷한 시점에 동일한 상품에 대해 재고 수 변경이 발생하는 경우
  각 MySQL 서버에서 처리되는 속도에 따라 실제로 쿼리가 유입된 순서와는 다른 순서로 데이터가 업데이트 될 수도 있다.
  만약, 하나의 MySQL 서버로 유입됐다면 잠금 경합으로 인해 순차적으로 처리되므로 이 같은 경우가 발생하지 않을 것이다.

  테이블에서 Auto-Increment 키를 사용하고 있는 경우
  동일한 시점에 새로운 데이터가 들어올 때 Auto-Increment 키 값을 갖게 될 수 잇으며, 이로 인해 복제에서 중복 키 에러가 발생할 수 있다.
  따라서, ACTIVE-ACTIVE 형태에서 Auto-Increment를 사용한다면 동시점에 동일한 데이터를 변경하는 트랜잭션이 있어서는 안 된다.
  Auto-Increment 대신 애플리케이션 단에서 글로벌하게 값을 생성해서 사용하는게 좋다.(UUID 근데, UUID 성능이 괜찮을까?)
  만약 Auto-Increment를 반드시 사용하고자 하는 경우에는
  키 값이 충돌하지 않도록 각 MySQL 서버에서 auto_increment_offset 변수와 auto_increment_increment 시스템 변수의 값을 적절히 사용해야 한다.

  트랜잭션 충돌로 인한 롤백이나 복제 멈춤 현상 등 역효과가 많고, 쓰기 처리량 또한 다른 소스 서버의 변경 내용을 복제를 통해 적용해야 되므로 효과가 크지 않다.
  이로 인해 실제로 멀티 소스 복제 구성은 많이 사용되지 않는다. 쓰기 성능의 확장이 필요하다면 멀티 소스 복제 구성보다는 샤딩하는 방법을 권장한다고 한다.
 */

### 16.6.5 - 멀티 소스 복제 구성
/**
  앞에서 봤듯이 멀티 소스 복제는 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태를 말한다.

  멀티 소스 복제 구성은 다음과 같은 목적으로 사용한다.
    - 여러 MySQL 서버에 존재하는 각기 다른 데이터를 하나의 MySQL 서버로 통합
    - 여러 MySQL 서버에 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합
    - 여러 MySQL 서버의 데이터들을 모아 하나의 MySQL 서버에서 백업을 수행

  분석을 위해 여러 곳에 나눠져 있는 데이터를 한 곳으로 모아 좀 더 빠르고 퍈리하게 수행하고자 할 때 멀티 소스 복제를 사용하면 매우 효율적이다.
  또한, 늘어날 트래픽에 대비해 사전에 동일한 스키마 구조를 가지는 샤드 형태로 구성해뒀으나 트래픽이 미미해 한 곳으로 통합 할 때에도 유용하다.
  다수의 MySQL 서버의 데이터를 하나의 MySQL 서버에서 백업하고자 할 때도 멀티 소스 복제 구성을 통해 손쉽게 구현할 수 있다.

  멀티 소스 복제의 레플리카 서버는 각 소스 서버들의 대체 서버로 사용하기에는 어려움이 있으므로 장애 대비용 레플리카 서버는
  멀티 소스가 아닌 각 소스 서버와 일대일 복제로 연결된 별도의 서버로 구축하는 것이 좋다.
 */

#### 16.6.5.1 - 멀티 소스 복제 동작
/**
  멀티 소스 복제에서 레플리카 서버는 자신과 연결된 소스 서버들의 변경 이벤트들을 동시점에 병렬로 동기화한다.
  이는 각 소스 서버에들에 대한 복제가 독립적으로 처리된느 것을 의미하며, 각각의 독립된 복제 처리를 채널이라고 한다.
  각 복제 채널은 개별적인 레플리케이션 I/O 스레드, 릴레이 로그, 레플레킹션 SQL 스레드를 가지며,
  채널의 이름은 어느 소스 서버와의 복제 연결인지를 구별할 수 있는 식별자 역할을 한다.
  멀티 소스 복제의 레플리카 서버는 최대 256개의 복제 채널을 생성할 수 있다.

  멀티 소스 복제에서 어느 소스 서버와의 복제 연결인지를 구별할 수 있는 식별자를 부여하는 방법으로는 FOR CHANNEL 이라는 명령을 통해 가능하다.
  만약, FOR CHANNEL 명령 없이 실행하게 되면 전체 복제 채녈에 대해 명령이 수행된다.

  멀티 소스 복제에서도 단일 소스 복제와 동일하게 GTID 설정이나 반동기 복제 방식 설정 등이 모두 가능하며,
  각 복제 채널별로 멀티 스레드로 복제를 처리하거나 소스 서버의 변경 이벤트를 필터링하도록 설정하는 것도 가능하다.
 */

 -- 이런 식으로 사용할 수 있다.
CHANGE [ REPLICATION SOURCE | MASTER ] TO ... FOR CHANNLE '채널이름';
START [ REPLICA | SLAVE ] [IO_THREAD | SQL_THREAD] FOR CHANNLE '채널이름';
STOP [ REPLICA | SLAVE ] [IO_THREAD | SQL_THREAD] FOR CHANNLE '채널이름';
RESET [ REPLICA | SLAVE ] FOR CHANNEL '채널이름';
SHOW [ REPLICA | SLAVE ] STATUS FOR CHANNEL '채널이름';
FLUSH RELAY LOGS FOR CHANNEL '채널이름';
SHOW RELAY LOG EVENTS FOR CHANNEL '채널이름';

#### 16.6.5.2 - 멀티 소스 복제 구축
/**
  멀티소스 복제라고 해서 기존의 단일 소스 복제와 구축하는 과정에 큰 차이가 있는 것은 아니다. 단, 백업 데이터를 레플리카 서버에 적재 할 때 신경써야 한다.

  -- mysqldump 와 같은 논리 수준의 백업 도구 이용
  소스 서버는 데이터를 mysqldump를 이용해 백업할 때는 InnoDB의 시스템 테이블 스페이스를 물리적으로 백업하는 것이 아니므로
  데이터를 적재할 때는 병합과 관련돼 문제가 발생하지 않는다. 하지만 백업된 데이터가 매우 크다면 XtraBackup과 같은 물리 수준의 백업 도구를 이용해야 한다.

  -- XtrapBackup 과 같은 물리 수준의 백업 도구 이용
  물리 수준의 백업 도구를 이용하면 대용량의 DB를 빠르게 레플리카 서버로 가져올 수 있따.
  InnoDB 스토리지 엔진과 같은 테이블은 시스템 테이블 스페이스에 테이블의 정보를 따로 보관한다. 그런데,
  XtraBacup과 같은 물리 수준의 백업은 시스템 테이블 스페이스를 포함해서 MySQL 서버의 모든 데이터 파일들을 그대로 복사해서 복구하게 된다.
  이때 만약 두 소스 서버에서 데이터를 가져와야 한다면 시스템 테이블 스페이스를 문제없이 하나로 병합할 수 있는 방법은 없다.

  여러 소스 서버의 데이터를 가져와 레플리카 서버의 초기 데이터를 적재할 때는 mysqldump와 XtraBackup을 적절히 혼합해서 사용하는 것이 제일 쉬운 방법이다.

  데이터 크기에 따라 어떻게 적절히 두 백업 도구를 혼합해서 사용하면 되는지 다음 예제를 살펴보자.
  ex) 소스 서버 a, b의 데이터를 가져와 레프리카 서버 c에서 멀티 소스 복제를 연결한다고 가정

  - a, b 서버 모두 데이터가 크지 않은 경우
    두 소스 서버 모두 가지고 있는 데이터가 크지 않아 mysqldump로도 충분히 백업할 수 있으며,
    레플리카 서버에서도 할당된 시간 내에 복구할 수 있을 것으로 예상된다면 a, b 서버의 mysqldump 결과를 차례대로 c 레플리카 서버에 적재하고,
    스토어드 프로시저나 함수, 유저 정보와 권환만 따로 확인해서 조정하면 된다.

  - a 서버의 데이터는 크고 b 서버의 데이터가 상댖거으로 훨씬 적은 경우
    데이터가 작은 쪽은 mysqldump를 데이터가 큰 쪽은 XtraBacup을 이용하면 된다.
    이때 a 서버의 데이터가 크그몰 a 서버의 데이터를 먼저 XtraBackup으로 레플리카 c에 복구한 다음
    b 서버의 데이터는 mysqldump로 백업해서 c에 적재한다.
    이 경우에도 스토어드 프로시저나 함수, 유저 정보와 권한 정보는 별도로 한번 더 확인하는 것이 좋다.

  - a 서버와 b 서버 모두 데이터가 큰 경우
    a, b 모두 큰 데이터를 가지고 있다면 둘 다 XtraBackup을 이용해 물리 수준의 백업을 수애한다.
    그리고 테이블의 개수가 많을 쪽을 먼저 레플리카 서버 c에 복구한다.
    남은 백업은 InnoDB의 시스템 테이블 스페이스 충돌로 인해 XtraBackup의 copy-back 명령으로는 복구할 수 없다.
    그래서 남은 백업에서 InnoDB 테이블들의 ibd 파일을 InnoDB Export 명령을 사용해 내보내고 레플리카 서버 C에 다시 import 하는 형태로 진행한다.
    테이블 스페이스를 익스포트하고 임포트하는 작업은 모두 수동으로 하나씩 진행해야 하므로 테이블의 수가 적은 쪽의 백업에 대해 이 방법을 수행하는 것이 좋다.

  위 방법들을 통해 a, b의 데이터를 모두 c로 가져왔다고 가정하고, 데이터가 덤프된 시점을 바탕으로 멀티 소스 복제를 구성해보자.
  복제 연결 전 한 가지 주의해야 할 부분은 레플리카 서버에서 복제 동작과 관련된
  master_info_repository, relay_log_info_repository 시세틈 변수들의 값이 반드시 TABLE로 설정돼 있어야 한다.
  이 두 시스템 변수들의 값이 FILE 이면 멀티 소스 복제를 설정할 수 없다.
 */
SHOW GLOBAL VARIABLES LIKE '%repository%';
SET GLOBAL master_info_repository ='TABLE';
SET GLOBAL relay_log_info_repository ='TABLE';

/**
  바이너리 로그 위치 기반으로 멀티 소스 복제를 진행하는 상황에서
  a 서버의 바이너리 로그 위치 : binary-log.000087, 100
  b 서버의 바이너리 로그 위치 : binary-log.000092, 200
 */
-- a라는 소스 서버와 연결하려면 다음과 같이 진행하면 된다. (8.0.23 버전 이상으로 적었다)
CHANGE REPLICATION SOURCE TO SOURCE_HOST='호스트이름_a', SOURCE_PORT=a_소스_포트,
    SOURCE_USER='a_복제_유저', SOURCE_PASSWORD='a_복제_패스워드',
    SOURCE_LOG_FILE='binary-log.000087', SOUCRE_LOG_POS=100
FOR CHANNEL 'source_a';

-- b라는 소스 서버와 연결하려면 다음과 같이 진행하면 된다. (8.0.23 버전 이상으로 적었다)
CHANGE REPLICATION SOURCE TO SOURCE_HOST='호스트이름_b', SOURCE_PORT=b_소스_포트,
    SOURCE_USER='b_복제_유저', SOURCE_PASSWORD='b_복제_패스워드',
    SOURCE_LOG_FILE='binary-log.000092', SOUCRE_LOG_POS=200
    FOR CHANNEL 'source_b';

--  소스 서버 a와 b에 대해 복제 시작
START REPLICA FOR CHANNEL 'source_a';
START REPLICA FOR CHANNEL 'source_b';

-- 한 번에 모두 시작
START REPLICA;

-- 복제 상태 확인
SHOW REPLICA STATUS \G;

/**
  GTID 기반으로 멀티 소스 복제를 진행하는 상황에서
  a 서버 GTID : aaaa-aaaa-aaaa-aaaa:1-1945
  b 서버 GTID : bbbb-bbbb-bbbb-bbbb:1-2261

  전에 GTID 복제를 구성할 때 확인했던 것처럼 gtid_executed 또는 gtid_purged 시스템 변수 등이 전에 사용하던 쓰레기 값으로 채워져 있다면
  RESET MASTER 명령을 이용해 모두 초기화해야 한다.
 */
-- gtid_executed, gtid_purged 시스템 변수가 빈 값인지 확인, 값이 채워져 있다면 RESET MASTER;
 SHOW GLOBAL VARIABLES LIKE '%gtid%';

/**
  gtid_purged 시스템 변수에 소스 서버들의 GTID 값을 넣는다.
  멀티 소스 복제와 같이 여러 대의 소스 서버가 존재하는 경우에는 각 소스 서버의 GTID 값을 쉼표(,)로 연결해서 한 번에 설정해야 한다.
  a, b 서버의 순서는 중요하지 않다.
 */
 -- 위에 있는 a, b gitd 값을 레플리카 서버 c에 등록
SET GLOBAL gtid_purged='aaaa-aaaa-aaaa-aaaa:1-1945,bbbb-bbbb-bbbb-bbbb:1-2261';
-- 정상적으로 입력됐는지 확인
SHOW GLOBAL VARIABLES LIKE '%gtid%';

-- 설정이 완료되면 CHANGE REPLICATION SOURCE TO 명령과 START REPLICA 명령을 사용해 복제를 설정 및 시작해야 한다.
-- 여기서도 마찬가지로 복제 연결에 대한 채널을 설정하는 부분을 잊으면 안된다.
-- a라는 소스 서버와 연결하려면 다음과 같이 진행하면 된다. (8.0.23 버전 이상으로 적었다)
CHANGE REPLICATION SOURCE TO SOURCE_HOST='호스트이름_a', SOURCE_PORT=a_소스_포트,
    SOURCE_USER='a_복제_유저', SOURCE_PASSWORD='a_복제_패스워드',
    SOURCE_AUTO_POSITION=1 FOR CHANNEL 'source_a';

-- b라는 소스 서버와 연결하려면 다음과 같이 진행하면 된다. (8.0.23 버전 이상으로 적었다)
CHANGE REPLICATION SOURCE TO SOURCE_HOST='호스트이름_b', SOURCE_PORT=b_소스_포트,
    SOURCE_USER='b_복제_유저', SOURCE_PASSWORD='b_복제_패스워드',
    SOURCE_AUTO_POSITION=1 FOR CHANNEL 'source_b';

--  소스 서버 a와 b에 대해 복제 시작
START REPLICA FOR CHANNEL 'source_a';
START REPLICA FOR CHANNEL 'source_b';

-- 한 번에 모두 시작
START REPLICA;

-- 복제 상태 확인
SHOW REPLICA STATUS \G;
