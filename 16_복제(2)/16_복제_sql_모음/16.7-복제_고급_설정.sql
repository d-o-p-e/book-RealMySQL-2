## 16.7 - 복제 고급 설정

### 16.7.1 - 지연된 복제(Delayed Replication)
/**
  복제는 최대한 빠르게 동기화해서 소스 서버와 레플리카 서버 간의 데이터를 동일한 상태로 만드는 것이 원래의 목적이다.
  하지만, 다음과 같은 상황을 고려해 의도적으로 소스 서버와 레플리카 서버 간의 복제를 지연시켜야 할 때가 있다.
   - 개발자나 DBA가 소스 서버에서 실수로 중요한 ㅔㅌ이블이나 데이터를 삭제한 상황
  이미 실수를 눈치했을 때는 레플리카 서버에서도 삭제 쿼리가 실행돼 버렸을 것이다. 이럴 때 어쩔 수 없이 서비스를 멈추고 백업을 사용해 복구해야 된다.

  위와 같은 상황에서 조금 더 유연하게 대처할 수 있도록 나온 기능이 '지연된 복제 기능'이다.
  지연된 복제를 사용하면 위에 상황이 발생할지라도 지연된 보게본을 통해 바로 데이터를 복구할 수 있다.
  이와 유사하게 이전 시점의 데이터 값에 대해 확인이 필요한 경우에도 백업 데이터를 사용하지 않고, 지연된 복제본에서 확인할 수 있고,
  데이터 반영에 지연이 있을 대 어떻게 서비스가 동작하는지 테스트할 때도 유용하다.
  보통 서버의 부하가 심할 때 쿼리 처리 지연 상황이 발생할 수 있는데, 지연된 복제본을 사용하면 굳이 부하를 생성할 필요없이 상황을 시뮬레이션할 수 있다.

  지연된 복제 기능은 5.6 버전에서 처음 도입됐으며, 8.0 버전에 와서는 몇 가지 부분들이 개선됐다.
  CHANGE REPLICATION SOURCE TO 구문에 SOURCE_DELAY 라는 옵션을 사용해 레플리카 서버를 소스 서버로부터 얼마나 지연시킬 것인지 지정할 수 있다.
 */
-- 86400 초를 설정함으로써 레플리카 서버가 소스 서버보다 하루 지연돼서 반영하게 만드는 예시
CHANGE REPLICATION SOURCE TO SOURCE_DELAY=86400;

/**
  8.0 버전부터는 바이너리 로그에 original_commit_timestamp(OCT)와 immediate_commit_timestamp(ICT)라는 타임 스탬프가 추가됐다.

  - original_commit_timestamp(OCT)
    트랜잭션이 원본 소스 서버(Original SOurce)에서 커밋된 시각으로, 밀리초 단위의 유닉스 타임스태프 값으로 저장된다.

  - immediate_commit_timestamp(ICT)
    트랜잭션이 직계 소스 서버(Immediate Source)에서 커밋된 시각으로, 밀리초 단위의 유닉스 타임스태프 값으로 저장된다.

  원본 소스 서버와 직계 소스 서버 용어가 헷갈리면 체인 복제 구성을 떠올리면 된다.
  MySQL 서버 세 대가 체인 형태로 구성된 복제에서 가장 하위에 있는 레플리카 서버를 기준으로 그 바로 위의 소스 서버가 직계 소스 서버,
  가장 위에 존재하는 소스 서버이다. 즉, 트랜잭션이 제일 처음 실행됐떤 소스 서버가 원본 소스 서버이다.

  OCT 값은 복제 구성에서 해당 트랜잭션이 복제되는 모든 레플리카 서버들이 동일한 값을 가진다.
  원본 소스 서버의 경우에는 OCT 값과 ICT 값이 동일하다.

  레플리카 서버가 바이너리 로그를 사용하고 log_slave_updates 옵션이 활성화돼 있는 경우,
  ICT에는 레플리카 서버에서 복제된 트랜잭션이 커밋된 시점으로 값이 저장된다.

  레플리카에서 SOURCE_DELAY 옵션에 값이 지정되면 ICT 타임스탬프 값을 참조해서 각 트랜잭션별로 실행을 지연시킬지 아니면 바로 실행할 것인지를 결정한다.
  8.0 버전 이전에선 개별 이벤트 단위로 지연 실행 여부를 확인하고, 지연 측정을 위한 기준 시각도 이벤트가 시작된 시각이 기준이였다.
  체인 복제를 구성하는 MySQL 서버들의 타임존이 서로 다른 경우에는 최하위 계층의 레플리카 서버에서 지연 시간이 예상된 것과는 다른 값으로 계산되어 표기된다.
  그러나, 8.0 버전부터는 ICT 타임스탬프 값을 사용함에 따라 이러한 문제점이 모두 개선됐다.

  지연된 복제를 사용하더라도 소스 서버의 바이너리 로그는 즉시 레플리카 서버의 릴레이 로그 파일로 복사된다.
  단지, 복제된 이벤트들에 대한 레플리케이션 SQL 스레드를 지연시키는 것일 뿐이다.
  그래서 소스 서버에 장애로 디스크의 데이터가 복구 불가능하다 하더라도 레플리카 서버의 릴레이 로그를 이용해서 복구한다면
  지연된 복제를 사용하지 않는 복제와 같이 레플리카 서버로의 장애 복구가 가능하다.
 */
-- 만약 복제를 지연되지 않도록 다시 설정하고 싶은 경우에는 다음 명령어를 실행해서 지연 설정을 제거하자.
STOP REPLICA SQL_THREAD;
CHANGE REPLICATION SOURCE TO SOURCE_DELAY=0;
START REPLICA SQL_THREAD;

### 16.7.2 - 멀티 스레드 복제(Multi-threaded Replication)
/**
  MySQL 복제에서는 레플리카 서버에서 소스 서버로부터 복제된 트랜잭션들을 여러 스레드로 처리할 수 있게 멀티 스레드 복제 기능을 제공한다.
  5.6 미만의 버전에서는 무조건 하나의 스레드로만 복제 동기화가 가능했다.
  하나의 스레드로만 사용했을 경우 소스 서버에서 짧은 시간 동안 다량의 DML 쿼리가 실행될 때 하나의 스레드가 모든 트랜잭션을 처리하므로 복제에 지연이 발생한다.
  또한, 하나의 스레드로만 복제 동기화가 이루어지는 것은 요즘 같이 멀티코어 CPU가 장착된 서버를 사용하는 환경에서 서버의 자원을 활용하지 못한다.

  기존의 단일 스레드 복제에서는 SQL 스레드가 릴레이 로그 파일을 읽어서 바로 트랜잭션을 적용하는 형태였다면,
  멀티 스레드 복제에서는 SQL 스레드를 코디네이터 스레드(Coordinator Thread)로 불리며,
  실제로 이벤트를 실행하는 스레드인 워커 스레드(Worker Thread)와 협업해서 동기화를 진행한다.

  코디네이터 스레드는 릴레이 로그 파일에서 이벤트들을 읽은 뒤 설정된 방식에 따라 스케줄링해서 워커 스레드에 각 이벤트를 할당한다.
  각 이벤트는 워커 스레드들의 큐에 적재되며, 워커 스레드는 큐에서 이벤트들을 꺼내 순차적으로 레플리카 서버에 적용한다.

  멀티 스레드 복제는 소스 서버로부터 복제된 트랜잭션들을 어떻게 병렬로 처리할 것인가에 따라 데이터베이스 기반과 LOGICAL CLOCK 기반 처리 방식으로 나뉜다.
  사용자는 slave_parallel_type 시세틈 변수를 통해 어떤 처리 방식으로 멀티 스레드 동기화를 진행할 것인지 설정할 수 있으며,
  slave_parallel_workers 시스템 변수를 통해 워커 스레드의 개수를 지정할 수 있다. 또한,
  slave_pending_jobs_size_max 시스템 변수를 통해 워커 스레드의 큐에 할당할 수 있는 최대 메모리 크기를 설정할 수 있다.
  위 세 변수 모두 동적으로 변경 가능하다.

    - slave_parallel_type 변수는 기본적으로 데이터베이스 기반 방식으로 설정된다.
    - slave_parallel_workers 시스템 변수에는 0부터 1024까지 설정할 수 있다.
        이 값을 0으로 설정하면 멀티 스레드 복제 동기화를 사용하지 않고 기존 단일 스레드 모드로 복제를 수행하게 된다.
        1로 설정했을 때는 멀티 스레드 복제를 위한 코디네이션 작업이나 워커 스레드 간의 동기화 등이 모두 실행되면서 실제 복제는 단일 스레드와 같은 형태로 수행된다.
    - slave_pending_jobs_size_max 시스템 변수는 8.0 버전의 기본값은 128MB로, 작은 이벤트들이 빈번하게 발생하는 OLTP 환경에서는 기본값 그대로 사용해도 무방하다.
        만약, 소스 서버로부터 전달받은 이벤트 하나의 크기가 여기 설정된 값을 초과하는 경우엔
        모든 워커 스레드들의 큐가 비워질 때까지 대기 후 이벤트가 처리된 후, 후속 이벤트들이 처리된다.
        이 경우 레플리카 서버에서 복제 지연이 발생하므로 필요 시 해당 변수의 값을 큰 값으로 변경하는 것이 좋다.

 */
-- 위 값들은 SHOW PROCESSLIST 명령을 통해 코디네이터 스레드와 쿼러 스레드를 확인할 수 있다.
SHOW PROCESSLIST;

#### 16.7.2.1 - 데이터베이스 기반 멀티 스레드 복제
/**
  데이터베이스 기반 멀티 스레드 복제 방식은 스키마 기반(Schema-based) 처리 방식이라고도 한다.
  이 방식은 이름 그대로 MySQL 내의 데이터베이스 단위로 병렬 처리를 수행하는 형태이다.
  따라서 MySQL 서버에 데이터베이스가 하나밖에 존재하지 않는다면 이 방식은 아무런 장점을 가지지 못한다.
  서버에 여러 개의 데이터베이스가 있다면 레플리카 서버에서는 그 개수만큼 워커 스레드 수를 설정하는 것이 좋다.

  코디네이터 스레드는 릴레이 로그 파일에서 이벤트를 읽어 데이터베이스 단위로 분리하고, 각 워커 스레드에게 이벤트들을 할당한다.
  이때 예를 들어 워커 스레드가 3개이고 DB1, DB2, DB3 이렇게 구성돼어 있을 때
  첫 번째와 두 번째 트랜잭션은 DB1, DB2 만 사용하는데, 세 번째 트랜잭션에서 DB3을 변경한 뒤 DB1을 변경하는 쿼리로 구성되어 있다고 가정해보자.

  첫 번째와 두 번째 트랜잭션은 각각의 워커 스레드로 전달한다. (서로 충돌하지 않으니까)
  세 번째 트랜잭션에서 두 번째 DML로 DB1을 변경하는 쿼리를 전달하려고 하는데, 첫 번째 워커 스레드가 실행 중인 DB1을 확인하고 바로 워커 스레드로 전달하지 않고,
  첫 번째 DB1을 수정하는 쿼리가 완료될 때까지 기다린 뒤 실행하게 된다.
  단, 데이터베이스 기반 멀티 스레드 복제에서는 테이블이나 레코드 수준까지의 충돌 여부는 고려하지 않고, 데이터베이스가 동일한지 아닌지만 비교해서 병렬 처리를 수행한다.
  또한, 세 번째 트랜잭션에서 두 번째 DML 문장을 실행하기 위해 기다리고 있는 상황에서 두 번째 워커 스레드의 작업이 완료 되었을 때
  네 번째 트랜잭션에서 DB2에 대한 DML 쿼리가 유입되는 경우에도 워커 스레드에 전달되지 않고 대기하게 된다.
  두 번째 트랜잭션이 완료되었다고 하더라도 앞서 대기하고 있는 트랜잭션으로 인해 실행을 못하게 되는 것이다.
  따라서, 서로 다른 데이터베이스를 참조하는 쿼리나 트랜잭션이 빈번하게 실행되는 경우 예상했던 것보다 멀티 스레드 처리 효율이 낮아질 수 있다. (샤딩 상황에서 그럴려나?)

  즉, MySQL 서버에 여러 개의 데이터베이스가 존재하고, 각 데이터베이스에 유입되는 DML이 서로 독립적이면서 양적으로 균등하게 실행되는 환경이라면
  데이터베이스 기반 멀티 스레드 복제는 충분히 사용 가치가 있는 방식이다.

  다음과 같이 설정한 후 복제를 연결하면 데이터베이스 기반 멀티 스레드 복제를 사용할 수 있다.
  [mysqld]
  slave_parallel_type='DATABASE'
  slave_parallel_workers=N (N > 1)

 */
-- 기존의 단일 스레드에서 데이터베이스 기반 멀티 스레드 복제로 전환하고 싶다면 SQL 스레드만 멈춘 후 멀티 스레드 복제를 설정하고 다시 시작하면 된다.
STOP REPLICA SQL_THREAD;
SET GLOBAL slave_parallel_type='DATABASE';
SET GLOBAL slave_parallel_workers=4;
START REPLICA SQL_THREAD;

#### 16.7.2.2 - LOGICAL CLOCK 기반 멀티 스레드 복제
/**
  데이터베이스 기반 멀티 스레드 복제에서는 MySQL 서버에 하나의 데이터베이스만 존재하는 경우 멀티 스레드로 처리될 수 업삳는 큰 단점이 있다.
  이로인해 MySQL 5.7 버전부터 소스 서버로부터 넘어온 전체 트랜잭션들을 데이터베이스에 종속되지 않고 멀티 스레드로 처리하는
  즉, 같은 데이터베이스 내에서도 멀티 스레드 동기화 처리가 가능한 LOGICAL CLOCK 방식이 도입돼서 위의 문제점들을 해소할 수 있게 됐다.

  LOGICAL CLOCK 방식은 소스 서버에서 트랜잭션들이 바이너리 로그로 기록될 때 각 트랜잭션별로 논리적인 순번 값을 부여해
  레플리카 서버에서 트랜재션의 순번 값을 바탕으로 정해진 기준에 따라 병렬로 실행할 수 있게 하는 방식이다.

  LOGICAL CLOCK 방식은 세 가지 방식이 있는데 각 방식에 대해 동작 원리 및 각 방식별로 어떠한 차이점이 있는지 살펴보자.
  1. Commit-parent 방식
  2. 잠금(Lock) 기반 방식
  - 이 두 방식의 경우 바이너리 로그 그룹 커밋과도 연관이 있으므로 아래 바이너리 로그 그룹 커밋에 대해 먼저 살펴보자.
  3. 8.0에서 새로운 WriteSet 기반 방식
 */

##### 16.7.2.2.1 - 바이너리 로그 그룹 커밋
/**
  5.5 버전까지는 클라이언트로부터 커밋 요청이 들어오면 MySQL 서버에서 "Prepare", "Commit"의 두 단계를 거쳐 커밋을 처리하는데,
  이를 분산 트랜잭션(XA, Two-Phase Commit)이라 한다.
  분산 트랜잭션은 트랜잭션을 커밋할 때 스토리지 엔진에 적용된 내용과 바이너리 로그에 기록된 내용 간의 일관성을 유지하기 위해 사용된다.

  이후에 내용들은 정리하기 어려워 RealMySQL 2권 책을 보는것을 추천드립니다.
 */

##### 16.7.2.2.2 - Commit-parent 기반 LOGICAL CLOCK 방식
/**
  이 방식은 멀티 스레드 복제 동기화가 처음 도입됐떤 5.7.2 버전부터 5.7.5 버전까지 적용된 방식으로,
  동일 시점에 커밋된 트랜잭션들을 레플리카 서버에서 병렬로 실행할 수 있게 한다.
  커밋 시점이 같은 트랜잭션들은 잠금 경합 등과 같이 서로 충하는 부분이 없는 트랜잭션들이므로 병렬로 실행될 수 있다.

  같은 시점에 커밋 처리된 트랜잭션들을 식별할 수 있도록 바이너리 로그에 트랜잭션을 기록할 때 commit_seq_no라는 값을 함께 기록한다.
  commit_seq_no에는 해당 트랜잭션이 커밋될 당시 가장 최근에 커밋된 트랜잭션의 순번 값이 저장되는데, 이러한 순번 값은
  MySQL 내부적으로 글로벌하게 관리되는 commit clock이라는 64비트 정숫값을 기반으로 한다.
  commit_seq_no는 각 트랜잭션이 커밋을 위해 Prepare 단계에 진입했을 때 설정되며 그 당시의 commit clock 값이 저장된다.
  commit clock은 트랜잭션이 최종적으로 스토리지 엔진에 커밋되기 전에 값이 증가한다.

  따라서, 같은 시점에 커밋 처리가 시작된 트랜잭션들은 동일한 commit_seq_no 값을 갖게 되며,
  레플리카 서버에서는 복제된 트랜잭션들의 commit_seq_no 값을 바탕으로 같은 값을 가진 트랜잭션들을 병렬로 처리하게 된다.
 */

##### 16.7.2.2.3 - 잠금 기반 LOGICAL CLOCK 방식
/**
  5.7.6 버전부터 잠금 기반 방식이 도입되어 Commit-parent 기반 방식은 더이상 사용되지 않는다.
  Commit-parent 기반 방식에서는 마지막으로 커밋된 선행 트랜잭션의 순번 값이 동일한 트랜잭션들만 레플리카 서버에서 병렬로 처리할 수 있었다.
  그러나 잠금 기반 방식에서는 선행 트랜잭션의 순번 값이 동일하지 않더라도 커밋 처리 시점이 겹친다면 해당 트랜잭션들은 레플리카 서버에서 병렬로 처리될 수 있다.

  이를 위해 MySQL 서버에서는 트랜잭션을 바이너리 로그에 기록할 때 "sequence_number", "last_committed"라는 값을 함께 기록한다.
  sequence_number는 커밋된 트랜잭션에 대한 논리적인 순번 값으로, 매 트랜잭션이 커밋될 때마다 값이 증가한다.
  last_committed에는 현 트랜잭션 이전에 커밋된 가장 최신 트랜잭션의 sequence_number 값이 저장된다.
  바이너리 로그 파일이 새로운 파일로 로테이션되는 경우 sequence_number 값은 1로 last_committed 값은 0으로 초기화 된다.

  잠금 기반 방식은 소스 서버에서 커밋 처리 시점이 겹치는 트랜잭션들의 수가 많을수록 레플리카 서버에서 최대한 병렬로 처리되므로,
  Commit-parent 기반 방식과 동일하게 소스 서버에서 그룹 커밋되는 트래잭션 수에 영향을 받는다.
 */

##### 16.7.2.2.4 - WriteSet 기반 LOGICAL CLOCK 방식
/**
  WriteSet 기반 방식은 8.0.1 버전부터 도입된 방식으로, 트랜잭션의 커밋 처리 시점이 아닌 트랜잭션이 '변경한 데이터를 기준으로' 병렬 처리 가능 여부를 결정한다.
  기존에서는 커밋 처리 시점이 전혀 겹치지 않는 두 트랜잭션은 병렬도 실행할 수 없는데, WriteSet 기반에선 두 트랜잭션이 서로 다른 데이터를 변경하는 것이라면
  병렬로 실행할 수 있다. 즉, 동일한 데이터를 변경하지 않는 트랜잭션들은 레플리카 서버에서 모두 병렬로 실행될 수 있다.

  WriteSet 기반에서는 같은 세션에서 실행된 트랜잭션들의 병렬 처리 여부에 따라 WRITESET과 WRITESET_SESSION 타입으로 다시 나눠진다.
  사용자는 binlog_transaction_dependency_tracking 시스템 변수를 통해 원하는 타입을 설정할 수 있으며,
  binlog_transaction_dependency_tracking 시스템 변수는 다음과 같은 값으로 설정 가능하다.

    - COMMIT_ORDER
        binlog_transaction_dependency_tracking 시스템 변수의 기본값으로, 기존 5.7 버전의 잠금 기반 방식과 동일하게 동작한다.
        즉, 커밋 처리 시점에 겹치는 트랜잭션들은 모두 병렬로 처리될 수 있다.
    - WRITESET
        서로 다른 데이터를 변경한 트랜잭션들은 모두 병렬로 처리될 수 있다.
    - WRITESET_SESSION
        동일한 세션에서 실행된 트랜잭션들은 병렬로 처리될 수 없다는 것 외에는 WRITESET과 동일하다.

  WriteSEt 기반 방식에서는 각 트랜잭션에서 변경한 데이터를 기준으로 병렬 처리를 위한 트랜잭션들의 종속 관계를 정의하므로,
  이를 위해 내부적으로 트랜잭션에 의해 변경된 데이터들의 목록을 관리한다.
  이 변경된 데이터들은 전부 해시값으로 표현되는데, 이 해싱된 변경 데이터를 "WriteSet"이라고 하고, 다음과 같은 조합으로 WriteSet이 생성된다.

  WriteSet = hash(index_name, db_name, db_name_length, table_name, table_name_length, value, value_length)

  WrteSet은 테이블에 존재하는 유니크한 키의 개수만큼 만들어진다. 따라서 하나의 변경 데이터는 여러 개의 WriteSet 가질 수 있다.
 */
-- 아래와 같은 테이블에서 INSERT 를 실행하면
CREATE TABLE t1 (
    id int NOT NULL AUTO_INCREMENT,
    col1 varchar(30) NOT NULL,
    col2 int NOT NULL,
    col3 int DEFAULT NULL,
    PRIMARY KEY (id),
    UNIQUE key ux_col1 (col1),
    key ix_co2 (col2)
);
insert into t1 VALUES (1, 'abc', 1, 10); -- 이 구문을 실행하면 다음과 같은 WriteSet 값이 생성된다.
-- WriteSet1 = hash(PRIMARY, db1, 3, t1, 2, 1, 1);
-- WriteSet2 = hash(ux_col1, db1, 3, t1, 2, 1, 'abc', 3);

/**
  WriteSet 을 생성할 때 사용되는 해시 알고리즘으로는 transaction_write_set_extraction 변수를 통해
  'OFF', 'MURMUR32', 'XXHASH64' 이 세 가지 값으로 설정 가능하며 기본값은 XXHASH64 이다.

  transaction_write_set_extraction 변수를 다른 값으로 변경하려면 바이너리 로그 포맷이 ROW 타입이어야 한다.

  WriteSet은 MySQL 서버 메모리에서 해시맵(Hash Map) 테이블로 그 히스토리가 관리된다.
  이 히스토리 테이블에는 변경된 데이터의 해시값인 WriteSet과 해당 데이터를 변경한 트랜잭션의 sequence_number 값이 Key-Value 형태로 저장된다.
  사용자는 binlog_transaction_dependency_history_size 시스템 변수를 통해
  히스토리 테이블이 최대로 가질 수 있는 해싱 데이터(WriteSet)의 수를 정할 수 있으며 기본 값은 25000 이다.
  저장된 데이터 수가 최대 개수만큼 도달하면 히스토리 테이블은 다시 초기화되며, DDL 쿼리가 실행된 경우에도 초기화된다.

  WriteSet 기반 방식도 트랜잭션이 커밋되면 바이너리 로그에 트랜잭션 정보와 함께 last_committed 값과 sequence_number 값이 기록된다.
  레플리카 서버에서는 이를 바탕으로 병렬 처리를 수행한다.

  WRITESET, WRITESET_SESSION 타입 모두 트랜잭션 커밋을 처리할 때 트랜잭션의 last_committed 값을 1차적으로 COMMIT_ORDER 타입 기반으로 설정하며,
  이후 WriteSet 히스토리 테이블 데이터를 조회해서 트랜잭션의 WriteSet과 충돌하는 WriteSet이 존재하는지 확인한 후 이를 바탕으로
  다시 last_committed 값을 설정하게 된다.

  즉, WriteSet 히스토리 테이블에 자신의 WriteSet과 충돌하는 WriteSet 데이터가 존재하는 경우
  WriteSet에 매핑된 sequence_number를 자신의 sequence_number 값으로 업데이트한다.
  이때 충돌하는 WriteSet이 여러 개가 존재할 때는 제일 큰 sequence_nuber로 last_committed 를 채운다.
  충돌하는 WriteSet이 하나도 없다면 해당 트랜잭션이 가진 WriteSet들이 히스토리 테이블에 새로 저장되고 트랜잭션의 last_committed에는 히스토리 테이블에 존재하는
  WriteSet 데이터 중 가장 작은 sequence_number 값이 저장된다.

  Write Session에서는 위 같이 저장된 last_commited 의 값을 같은 세션에서 커밋된 마지막 트랜잭션의
  sequence_number 값과 한번 더 비교해서 둘 중 더 큰 값을 선택해 last_committed에 저장한다.

  WRITESET과 WRITESET_SESSION 타입 모두 트랜잭션에서 변경된 데이터들이 속하는 테이블이 유니크한 키를 가지고 있찌 않은 경우
  해당 트랜잭션의 WriteSet은 생성되지 않으며, 이때 last_committed에는 COMIT_ORDER 타입 기반으로 결정된 값이 그대로 유지되어 최종적으로 사용된다.

  WriteSet 방식은 binlog_format이 ROW여야 정상적으로 작동하며, WriteSet 기반 방식을 사용하기 위해서는 소스 서버와 레플리카 서버를 다음과 같이 설정하면 된다.
    -- 소스 서버 설정
    [mysqld]
    binlog_format=ROW
    binlog_transaction_dependency_tracking={WRITESET | WRITESET_SESSION}
    transaction_write_set_extraction=XXHASH64

    -- 레플리카 서버 설정
    [mysqld]
    binlog_format=ROW
    slave_parallel_type=LOGICAL_CLOCK
    slave_parallel_workers=N (N > 1)
 */;

#### 16.7.2.3 - 멀티 스레드 복제와 복제 포지션 정보
/**
  멀티 스레드 복제에서 각 워커 스레드들이 실행한 바이너리 로그 이벤트의 포지션 정보는 relay_log_info_repository 시스템 변수에 지정된 값에 따라
  MySQL 서버의 mysql 데이터베이스 내 slave_worker_info 테이블 혹은 데이터 디렉터리 내 'worker-relay-log.info' 라는 접드사를 가지는 파일에서
  각 스레드별로 저장되며, 워커 스레드들은 이벤트를 실행 완료할 때마다 해당 데이터를 갱신한다.

  현재 복제 이벤트의 처리 현황을 보여주는 어플라이어(Applier) 와
  메타데이터(mysql.slave_relay_log_info 테이블 또는 relay-log.info 파일에 저장되는 데이터) 에는
  워커 스레드들이 실행한 이벤트들에서 로우 워터마크에 해당하는 이벤트의 포지션 값이 저장되는데,
  이 값은 코디네이터 스레드가 수행하는 체크포인트 작업에 의해 주기적으로 갱신된다.
 */
select * from mysql.slave_worker_info;

### 16.7.3 - 크래시 세이프 복제(Crash-safe Replication)
/**
  MySQL이 비정상 종료된 후 재구동됐을 대도 복제가 원할하게 재개될 수 있게 여러 설정을 제공한다.
  이를 통해 사용자는 서버 장애 이후에도 문제없이 복제가 진행되는 크래시 세이프 복제(Crash-sfae Replication)를 실현할 수 있다.
  크래시 세이프 복제는 여러 가지 복제 관련 옵션들을 복제 사용형태에 따라 적절히 설정했을 대 얻게 되는 효과라 할 수 있다.
 */

#### 16.7.3.1 - 서버 장애와 복제 실패
/**
  전에 나왔던 FILE 형태와 TABLE 형태의 이야기가 나온다. 아래 나오는 이야기는 SQL 스레드 관련 이야기이다.
  FILE 형태에서 비정상적으로 종료됐을 때 원자적으로 실행되지 않아 데이터 불일치 또는 중복 키 에러가 발생할 수 있다.
  TABLE 형태는 원자적으로 실행되므로 위와 같은 에러를 방지할 수 있다.
  그러나, TABLE 형태라고 하더라도 릴레이 로그 파일에 이벤트를 쓰는 작업과 포지션 정보를 업데이트하는 작업이 (I/O 스레드의 작업이)
  SQL 스레드처럼 원자적으로 처리도리 수 없어 여전히 불일치 문제가 발생할 가능성이 있다.

  하지만, I/O 스레드의 포지션 불일치 문제는 relay_log_recovery 옵션이 도입되면서 해결되었다.
  해당 옵션은 I/O 스레드의 포지션을 SQL 스레드가 마지막으로 실행했떤 포지션으로 초기화하고, 새로운 릴레이 로그 파일을 생성해서
  SQL 스레드가 읽어야 할 릴레이 로그 포지션 위치를 초기화한다. 이 과정으로 인해 마지막에 실행했떤 트랜잭션 이후로 정상적인 복제를 시작할 수 있다.

  따라서, 크래시 세이프 복제를 위해 MySQL 서버의 최소한으로 적용돼야 하는 옵션은 다음과 같다.
  [mysqld]
  relay_log_recovery=ON
  relay_log_info_repository=TABLE

  relay_log_recovery 옵션은 동적으로 변경할 수 없는 옵션으로 서버를 구동할 때 커맨드 라인이나 설정 파일에 명시해야 한다.
  8.0 버전에서는 기본적으로 relay_log_info_repository 옵션 값이 TABLE 이므로 8.0 이상의 버전을 사용한다면 굳이 명시하지 않아도 된다.

  또한, 위 설정은 MySQL 서버의 비정상 종료에만 크래시 세이프한 것이지 서버 장비 또는 운영체제가 비정상 종료되는 경우에는 무용지물일 수 있다.
 */

#### 16.7.3.2 - 복제 사용 형태별 크래시 세이프 복제 설정
-- 복제 방식을 크게 네 가지로 나누어 각 방식에서 크래시 세이프 복제 설정을 알아보자.

##### 16.7.3.2.1 - 바이너리 로그 파일 위치 기반 복제 + 싱글 스레드 동기화
/**
  바이너리 로그 파일 위치 기반이면서 싱글 스레드로 복제 동기화가 처리되는 복제 형태에서는 다음과 같이 옵션을 설정했을 때 크래시 세이프 복제가 된다.
  ## 레플리카 서버 my.cnf
  relay_log_recovery=ON
  relay_log_info_repository=TABLE
  최소 옵션 설정 셋과 동이하며, MySQL 서버만 비정상으로 종료됐을 경우에 한해 복제가 정상적으로 재개될 수 있다.
 */

##### 16.7.3.2.2 - 바이너리 로그 파일 위치 기반 복제 + 멀티 스레드 동기화
/**
  바이너리 로그 파일 위치 기반이면서 멀티 스레드로 복제 동기화가 처리되는 형태에서는
  레플리카 서버에서 복제된 트랜잭션들의 커밋 순서가 소스 서버에서와 동일하도록 설정됐는지 여부에 따라 크래시 세이프 복제를 위한 옵션 셋이 달라진다.

  소스 서버와 트랜잭션 커밋 순서 일치 - 레플리카 서버에서 다음과 같이 설정된 경우를 뜻한다.
  ## 레플리카 서버 my.cnf
  slave_parallel_type=LOGICAL_CLOCK
  slave_preserve_commit_order=1
  -- 이렇게 설정된 경우 기본 셋만 설정하면 된다.

  일치하지 않는 경우 - 다음과 같이 설정된 경우
  ## 레플리카 서버 my.cnf
  slave_parallel_type=DATABASE
  또는
  slave_parallel_type=LOGICAL_CLOCK
  slave_preserve_commit_order=0
  -- 이렇게 된 경우 기본 셋에서 sync_relay_log=1 이 부분만 추가하면 된다.

  sync_relay_log는 릴레이 로그를 디스크와 얼마나 자주 동기화할 것인지 제어하는 옵션으로,
  0으로 설정되면 MySQL에서는 동기화하지 않고 운영체제 설정에 따라 동기화가 수행한다.
  0보다 크게 설정하는 경우는 릴레이 로그에 지정된 수만큼 이벤트가 기록됐을 대 디스크와 동기화한다.
  해당 옵션의 기본값은 10000이며, 1이 아닌 0이나 1 이상의 값을 사용하면
  MySQL이 비정상적으로 종료됐을 때 미처 디스크에 동기화되지 못한 릴레이 로그의 내용이 유실될 가능성이 있다.
  이로 인해 MySQL 서버가 다시 구동됐을 때 복제가 실패할 수 있고, 이유는 멀티 스레드로 동기화될 때 발생할 수 있는 트랜잭션 갭 때문이다.
    - 트랜잭션 갭 : 멀티 스레드 복제에서 병렬 처리로 인해 트랜잭션들이 순서대로 처리되지 않아 일시적으로 발생하는 트랜잭션들 간의 간격을 의미한다.

  멀티 스레드 복제를 사용할 때는 LOGICAL_CLOCK 방식을 사용하고, slave_preserve_commit_order 옵션을 1로 설정해서
  트랜잭션 갭이 발생하지 않게 함으로써 sync_relay_log=1 설정 없이도 크래시 세이프한 복제가 될 수 있게 하는 것을 권장한다.
 */

##### 16.7.3.2.3 - GTID 기반 복제 + 싱글 스레드 동기화
/**
  GTID 기반이면서 싱글 스레드로 복제 동기화가 처리되는 복제 형태에서는 mysql.gtid_executed 테이블 데이터가
  복제된 트랜잭션이 적용될 때마다 매번 함께 갱신되는지 여부에 따라 크래시 세이프 복제를 위한 옵션 셋이 달라진다.

  -- gtid_executed 테이블 데이터가 매 트랜잭션 적용시 갱신되는 경우
  ## 레플리카 서버 my.cnf
  relay_log_recovery=ON
  SOURCE_AUTO_POSITION=1

  -- gtid_executed 테이블 데이터가 매 트랜잭션 적용시 갱신되지 않는 경우
  ## 레플리카 서버 my.cnf
  relay_log_recovery=ON
  SOURCE_AUTO_POSITION=1
  sync_binlog=1
  innodb_flush_log_at_trx_commit=1

  gtid_executed 테이블 데이터는 8.0.17 미만의 버전에서는 MySQL 서버 설정에 따라 달라지고,
  이상의 버전에선 기본적으로 매 트랜잭션 적용시 함께 갱신된다.
 */

##### 16.7.3.2.4 - GTID 기반 복제 + 멀티 스레드 동기화
/**
  GTID 기반이면서 멀티 스레드로 복제 동기화가 처리된느 복제 형태는 싱글 스레드로 동기화되는 경우와 동일하다.
  gtid_executed 테이블 데이터에 따라 달라지는 것까지도 동일하다.

  다만, 멀티 스레드 복제인 경우 앞에서 봤듯이 트랜잭션 갭을 메우는 작업으로 인해 복제가 실패하기도 하는데
  8.0.18/5.7.28 버전부터는 GTID 기반이면서 SOURCE_AUTO_POSITION 옵션을 사용하는 경우 이러한 작업이 자동으로 생략되도록 됐다.
  단, 8.0.18/5.7.28 미만의 버전에서는 문제가 발생할 수 있는데, 이럴 경우 다음과 같이 한 뒤 복제를 정상적으로 재개할 수 있다.
  mysql_Replica> STOP SLAVE; RESET SLAVE; START SLAVE;
 */

### 16.7.4 - 필터링된 복제(Filtered Replication)
/**
  소스 서버의 특정 이벤트들만 레플리카 서버에 적용될 수 있도록 필터링 기능을 제공한다.
  필터링의 주체는 소스 서버와 레플리카 서버 둘 다 될 수 있으며, 레플리카 서버에서 좀 더 다양한 형태의 필터링을 사용할 수 있다.

  소스 서버에서는 발생한 이벤트들 중 특정 이벤트들만 바이너리 로그에 기록, 기록하지 않음으로써 이벤트가 필터링 될 수 있게 한다.
  소스 서버에서의 필터링은 데이터베이스 단위로만 가능하며, 다음 두 옵션들을 사용해 특정 데이터베이스에 대한 이벤트들만 필터링할 수 있다.
    - binlog_do-db
        바이너리 로그에 기록할 데이터베이스 명을 지정한다.
        이 옵션에 지정된 데이터베이스에 대한 이벤트들만 바이너리 로그에 기록된다.
    - binlog-ignore-db
        바이너리 로그에 기록하지 않을 데이터베이스 명을 지정
        이 옵션에 지정된 데이터베이스에 대한 이벤트들은 바이너리 로그에 기록되지 않는다.
  이 두 옵션은 MySQL 서버를 시작할 때 커맨드 라인이나 설정 파일에 지정해서 사용 가능하며, 서버를 구동하는 중에는 동적으로 값을 변경할 수 없다.
  -- my.cnf 파일 설정
  [mysqld]
  binlog-do-db=production
  binlog-do-db=production2 -- 여러 개의 데이터베이스들을 사용하고 싶으면 각 데이터베이스별로 옵션을 중복해서 적어야 한다.
  binlog-ignore-db=test

  레플리카 서버에서는 소스 서버와 달리 서버를 재시작하지 않고 동적으로 필터링 설정을 변경할 수도 있다.
  레플리카 서버에서의 필터링은 릴레이 로그에 저장된 이벤트들을 실행하는 시점에 적용된다.
  즉, 소스 서버로부터 모든 이벤트를 가져온 다음 이벤트를 실행할 때 필터링을 적용한다는 것이다.
  동적으로 변경하고 싶다면 레플리카 서버가 구동 중인 상태에서 CHANGE REPLICATION FILTER 구문을 사용해 필터링을 설정할 수 있디.

  -- CHANGE REPLICATION FILTER 구문을 사용하는 방식
  CHANGE REPLICATION FILTER filter[, filter, ...] [FOR CHANNEL channel_nale]

  filter:
    REPLICATE_DO_DB = (db_name[, db_name, ...])
    REPLICATE_IGNORE_DB =       ||
    REPLICATE_DO_TABLE = (db_name.table_name[, db_name.tablename, ...])
    REPLICATE_IGNORE_TABLE =                ||
    REPLICATE_WILD_DO_TABLE = ('db_pattern.table_pattern'[, 'db_pattern.table_pattern', ...])
    REPLICATE_WILD_IGNORE_TABLE =              ||
    REPLICATE_REWRITE_DB = ((from_db, to_db)[, (from_db, to_db), ...])

  CHANGE REPLICATION FILTER 구문을 사용해 복제 필터링을 적용하려면 복제를 시작하기 전 해당 구문을 실행하거나 혹은,
  복제가 이미 시작된 상태라면 STOP REPLICA SQL_THREAD 명령을 먼저 실행해 SQL 스레드를 멈춘 후
  CHANGE ... 구문을 실행한 다음 START REPLICA SQL_THREAD 명령으로 SQL 스레드를 실행해야 한다.
  *** 단, CHANGE 명령은 MySQL 서버가 재시작하면 전부 초기화 되므로 설정 파일을 적어놓도록 하자. ***

  설정된 복제 필터링 옵션들을 해제하려면 해제하고자 하는 필터링 옵션들을 명시적으로 빈 값으로 설정해서 실행하면 된다.
  ex) CHANGE REPLICATION FILTER REPLICATE_DO_DB = (), REPLICATE_IGNORE_DB = (), ... ;

  레플리카 서버에서 필터링 처리가 일관될 수 있도록 바이너리 로그 포맷에 따라 어떻게 사용하면 좋을까? (554p)
    - `ROW` 포맷 사용 시
        - `DDL`은 `USE 데이터베이스_명;`을 사용해 디폴트 데이터베이스 설정되게 하고 쿼리에서 데이터베이스명을 지정하지 않는다.
    - `STATEMENT` 또는 `MIXED` 포맷 사용 시
        - `DML`, `DDL` 모두 `USE 데이터베이스_명;`을 사용해 디폴트 데이터베이스 설정되게 하고 쿼리에서 데이터베이스 명을 지정하지 않는다.
        - 또한, 복제 대상 테이블과 복제 제외 대상 테이블을 모두 변경하는 `DML`을 사용하지 않는다.
 */

